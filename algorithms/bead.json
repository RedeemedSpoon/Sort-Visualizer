{
  "Name": "Bead Sort",
  "Date": "2002",
  "Author": "Joshua J. Arulanandham, Cristian S. Calude and Michael J. Dinneen",
  "Description": "Bead sort, also known as counting sort with linked lists, is a less common sorting technique that utilizes physical beads with unique colors to represent the data. It relies on the ability to physically manipulate the beads based on their colors. While conceptually interesting, bead sort is a theoretical algorithm not typically used in practical sorting tasks.",
  "Complexity": {
    "Time": "O(S)",
    "Best": "O(n)",
    "Worst": "O(S)",
    "Space": "O(nÂ²)",
    "Stable": "Unknown"
  },
  "Algorithm": "async function sort(){let r=Math.max(...array),a=array.length;const e=new Array(a).fill().map((()=>new Array(r).fill(0)));for(let r=0;r<a;r++)for(let a=0;a<array[r];a++)e[r][a]=1;for(let l=0;l<r;l++){let r=0;for(let t=0;t<a;t++)r+=e[t][l],e[t][l]=0;for(let t=a-1;t>=a-r;t--)e[t][l]=1}for(let l=0;l<a;l++){let a=0;for(let t=0;t<r;t++)a+=e[l][t];if(swap(l,array.indexOf(a)),await sleep(),firstRun)return}console.log(array)}",
  "Code": {
    "Python": "def bead_sort(numbers):\n\trows = max(numbers) + 1\n\tcols = len(numbers)\n\tbeads = [[0 for _ in range(cols)] for _ in range(rows)]\n\tfor num in numbers:\n\t\tbeads[num][numbers.index(num)] = 1\n\tfor col in range(cols):\n\t\tfor row in range(rows - 2, -1, -1):\n\t\t\tif beads[row][col] == 1:\n\t\t\t\tbeads[row][col] = 0\n\t\t\t\tbeads[row + 1][col] = 1\n\tsorted_numbers = []\n\tfor col in range(cols):\n\t\tif beads[0][col] == 1:\n\t\t\tsorted_numbers.append(col)\n\treturn sorted_numbers\n\n# Example usage\nnumbers = [3, 1, 4, 1, 5, 9, 2, 6]\nprint(\"Original numbers:\", numbers)\nsorted_numbers = bead_sort(numbers.copy())  # Avoid modifying the original list\nprint(\"Sorted numbers:\", sorted_numbers)",
    "JavaScript": "function beadSort(numbers) {\n\tconst rows = Math.max(...numbers) + 1;\n\tconst cols = numbers.length;\n\tconst beads = Array.from({ length: rows }, () => Array(cols).fill(0));\n\t\tnumbers.forEach((num, index) => beads[num][index] = 1);\n\tfor (let col = 0; col < cols; col++) {\n\t\tfor (let row = rows - 2; row >= 0; row--) {\n\t\t\tif (beads[row][col] === 1) {\n\t\t\t\tbeads[row][col] = 0;\n\t\t\t\tbeads[row + 1][col] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tconst sortedNumbers = [];\n\tfor (let col = 0; col < cols; col++) {\n\t\tif (beads[0][col] === 1) {\n\t\t\tsortedNumbers.push(col);\n\t\t}\n\t}\n\treturn sortedNumbers;\n}\n\n// Example usage\nconst numbers = [3, 1, 4, 1, 5, 9, 2, 6];\nconsole.log(\"Original numbers:\", numbers);\nconst sortedNumbers = beadSort([...numbers]);  // Spread operator to avoid modifying the original array\nconsole.log(\"Sorted numbers:\", sortedNumbers);",
    "Java": "public class BeadSort { public static int[] beadSort(int[] numbers) {\n\tint rows = Arrays.stream(numbers).max().getAsInt() + 1; \n\tint cols = numbers.length; \n\t\tint[][] beads = new int[rows][cols]; \n\tfor (int i = 0; i < numbers.length; i++) { \n\t\tbeads[numbers[i]][i] = 1; \n\t} \n\tfor (int col = 0; col < cols; col++) { \n\t\tfor (int row = rows - 2; row >= 0; row--) { \n\t\t\tif (beads[row][col] == 1) { \n\t\t\t\tbeads[row][col] = 0; \n\t\t\t\tbeads[row + 1][col] = 1; \n\t\t\t}\n\t\t}\n\t} \n\t\tint[] sortedNumbers = new int[cols]; \n\t\tint index = 0; \n\tfor (int col = 0; col < cols; col++) { \n\t\tif (beads[0][col] == 1) { \n\t\t\tsortedNumbers[index++] = col; \n\t\t}\n\t}\n\treturn sortedNumbers; \n} } \n\n// Example usage \nint[] numbers = {3, 1, 4, 1, 5, 9, 2, 6}; \nSystem.out.println(\"Original numbers: \" + Arrays.toString(numbers)); \nint[] sortedNumbers = beadSort(numbers.clone());  // Clone to avoid modifying the original array \nSystem.out.println(\"Sorted numbers: \" + Arrays.toString(sortedNumbers));",
    "Go": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc beadSort(numbers []int) []int {\n\t\n\trows := max(numbers) + 1\n\tcols := len(numbers)\n\tbeads := make([][]int, rows)\n\tfor i := range beads {\n\t\tbeads[i] = make([]int, cols)\n\t}\n\tfor i, num := range numbers {\n\t\tbeads[num][i] = 1\n\t}\n\tfor col := range numbers {\n\t\tfor row := rows - 2; row >= 0; row-- {\n\t\t\tif beads[row][col] == 1 {\n\t\t\t\tbeads[row][col] = 0\n\t\t\t\tbeads[row+1][col] = 1\n\t\t\t}\n\t\t}\n\t}\n\tsortedNumbers := make([]int, 0, cols)\n\tfor col := range numbers {\n\t\tif beads[0][col] == 1 {\n\t\t\tsortedNumbers = append(sortedNumbers, col)\n\t\t}\n\t}\n\treturn sortedNumbers\n}\n\nfunc max(arr []int) int {\n\tmaxVal := arr[0]\n\tfor _, val := range arr {\n\t\tif val > maxVal {\n\t\t\tmaxVal = val\n\t\t}\n\t}\n\treturn maxVal\n} \n\nfunc main() {\n\tnumbers := []int{3, 1, 4, 1, 5, 9, 2, 6}\n\tfmt.Println(\"Original numbers:\", numbers)\n\tsortedNumbers := beadSort(numbers)\n\tfmt.Println(\"Sorted numbers:\", sortedNumbers)\n}",
    "C": "#include <stdio.h>\n#include <stdlib.h>\n\nint *beadSort(int *numbers, int n) {\n\tint rows = *numbers + 1;\n\tint cols = n;\n\t\tint **beads = malloc(rows * sizeof(int*));\n\tfor (int i = 0; i < rows; i++) {\n\t\tbeads[i] = malloc(cols * sizeof(int));\n\t\tfor (int j = 0; j < cols; j++) {\n\t\t\tbeads[i][j] = 0;  // Initialize all beads to empty (0)\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tbeads[numbers[i]][i] = 1;\n\t}\n\tfor (int col = 0; col < n; col++) {\n\t\tfor (int row = rows - 2; row >= 0; row--) {\n\t\t\tif (beads[row][col] == 1) {\n\t\t\t\tbeads[row][col] = 0;\n\t\t\t\tbeads[row + 1][col] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\tint *sortedNumbers = malloc(n * sizeof(int));\n\t\tint index = 0;\n\tfor (int col = 0; col < n; col++) {\n\t\tif (beads[0][col] == 1) {\n\t\t\tsortedNumbers[index++] = col;\n\t\t}\n\t}\n\tfor (int i = 0; i < rows; i++) {\n\t\tfree(beads[i]);\n\t}\n\tfree(beads);\n\treturn sortedNumbers;\n}\n\nint main() {\n\tint numbers[] = {3, 1, 4, 1, 5, 9, 2, 6};\n\tint n = sizeof(numbers) / sizeof(numbers[0]);\n\tprintf(\"Original numbers: \");\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", numbers[i]);\n\t}\n\tprintf(\"\\n\");\n\tint *sortedNumbers = beadSort(numbers, n);\n\tprintf(\"Sorted numbers: \");\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", sortedNumbers[i]);\n\t}\n\tprintf(\"\\n\");\n\tfree(sortedNumbers);  // Free memory allocated for sorted numbers\n\treturn 0;\n}"
  }
}
