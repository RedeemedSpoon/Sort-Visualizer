{
  "Name": "Bitonic Sort",
  "Date": "1960s",
  "Author": "Kenneth E. Batcher",
  "Description": "Bitonic sort is a sorting algorithm designed for parallel computing environments. It operates on a bitonic sequence (a sequence that is first increasing and then decreasing, or vice versa). The algorithm recursively divides the sequence into smaller bitonic sub-sequences and sorts them using a specific compare-swap operation.\n\n Bitonic sort leverages the capabilities of parallel processors to achieve efficient sorting. However, its practical use often requires specialized hardware or algorithms tailored for parallel execution.",
  "Complexity": {
    "Time": "O(log² n)",
    "Best": "O(log² n)",
    "Worst": "O(n log² n)",
    "Space": "O(1)",
    "Stable": "No"
  },
  "Algorithm": "async function sort(){let r,a,t,f,n=array.length;for(r=2;r<=n;r*=2)for(a=r/2;a>0;a/=2)for(f=0;f<n;f++)if(t=f^a,t>f&&(0==(f&r)&&array[f]>array[t]||0!=(f&r)&&array[f]<array[t])&&(swap(f,t),await sleep(),firstRun))return}",
  "Code": {
    "Python": "def bitonic_merge(arr, lo, cnt, dir):\n\tif cnt > 1:\n\t\tmid = lo + cnt // 2\n\t\tif dir == 1:\n\t\t\tbitonic_merge(arr, lo, cnt // 2, 1)\n\t\t\tbitonic_merge(arr, mid, cnt // 2, 0)\n\t\telse:\n\t\t\tbitonic_merge(arr, mid, cnt // 2, 0)\n\t\t\tbitonic_merge(arr, lo, cnt // 2, 1)\n\tif dir == 0:\n\t\tif arr[lo] > arr[lo + cnt - 1]:\n\t\t\tarr[lo], arr[lo + cnt - 1] = arr[lo + cnt - 1], arr[lo]\n\ndef bitonic_sort(arr, n, dir):\n\tif n > 1:\n\t\tfor i in range(0, n, 2):\n\t\t\tbitonic_merge(arr, i, 2, dir)\n\t\tbitonic_sort(arr, n // 2, 0 if dir else 1)\n\t\tbitonic_sort(arr, n // 2, 1 if dir else 0)\n\n# Test array\narr = [8, 1, 2, 3, 7, 6, 5, 4]\nbitonic_sort(arr, len(arr), 1)\nprint('Sorted array:', arr)",
    "JavaScript": "function bitonicMerge(arr, lo, cnt, dir) {\n\tif (cnt > 1) {\n\t\tconst mid = lo + Math.floor(cnt / 2);\n\t\tif (dir === 1) {\n\t\t\tbitonicMerge(arr, lo, cnt / 2, 1);\n\t\t\tbitonicMerge(arr, mid, cnt / 2, 0);\n\t\t} else {\n\t\t\tbitonicMerge(arr, mid, cnt / 2, 0);\n\t\t\tbitonicMerge(arr, lo, cnt / 2, 1);\n\t\t}\n\t}\n\tif (dir === 0) {\n\t\tif (arr[lo] > arr[lo + cnt - 1]) {\n\t\t\t[arr[lo], arr[lo + cnt - 1]] = [arr[lo + cnt - 1], arr[lo]];\n\t\t}\n\t}\n}\n\nfunction bitonicSort(arr, n, dir) {\n\tif (n > 1) {\n\t\tfor (let i = 0; i < n; i += 2) {\n\t\t\tbitonicMerge(arr, i, 2, dir);\n\t\t}\n\t\tbitonicSort(arr, Math.floor(n / 2), 0 === dir ? 0 : 1);\n\t\tbitonicSort(arr, Math.floor(n / 2), 1 === dir ? 0 : 1);\n\t}\n}\n\n// Test array\nconst arr = [8, 1, 2, 3, 7, 6, 5, 4];\nbitonicSort(arr, arr.length, 1);\nconsole.log('Sorted array:', arr);",
    "Java": "public class BitonicSort {\n\tpublic static void bitonicMerge(int[] arr, int lo, int cnt, int dir) {\n\t\tif (cnt > 1) {\n\t\t\tint mid = lo + cnt / 2;\n\t\t\tif (dir == 1) {\n\t\t\t\tbitonicMerge(arr, lo, cnt / 2, 1);\n\t\t\t\tbitonicMerge(arr, mid, cnt / 2, 0);\n\t\t\t} else {\n\t\t\t\tbitonicMerge(arr, mid, cnt / 2, 0);\n\t\t\t\tbitonicMerge(arr, lo, cnt / 2, 1);\n\t\t\t}\n\t\t}\n\t\tif (dir == 0 && arr[lo] > arr[lo + cnt - 1]) {\n\t\t\tswap(arr, lo, lo + cnt - 1);\n\t\t}\n\t}\n\n\tprivate static void swap(int[] arr, int i, int j) {\n\t\tint temp = arr[i];\n\t\tarr[i] = arr[j];\n\t\tarr[j] = temp;\n\t}\n\n\tpublic static void bitonicSort(int[] arr, int n, int dir) {\n\t\tif (n > 1) {\n\t\t\tfor (int i = 0; i < n; i += 2) {\n\t\t\t\tbitonicMerge(arr, i, 2, dir);\n\t\t\t}\n\t\t\tbitonicSort(arr, n / 2, 0 if dir == 1 else 1);\n\t\t\tbitonicSort(arr, n / 2, 1 if dir == 1 else 0);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint[] arr = {8, 1, 2, 3, 7, 6, 5, 4};\n\t\tbitonicSort(arr, arr.length, 1);\n\t\tSystem.out.print(\"Sorted array is: \");\n\t\tfor (int num : arr) {\n\t\t\tSystem.out.print(num + \" \");\n\t\t}\n\t}\n}",
    "Go": "package main\n\nfunc bitonicMerge(arr []int, lo, cnt, dir int) {\n\tif cnt > 1 {\n\t\tmid := lo + cnt/2\n\t\tif dir == 1 {\n\t\t\tbitonicMerge(arr, lo, cnt/2, 1)\n\t\t\tbitonicMerge(arr, mid, cnt/2, 0)\n\t\t} else {\n\t\t\tbitonicMerge(arr, mid, cnt/2, 0)\n\t\t\tbitonicMerge(arr, lo, cnt/2, 1)\n\t\t}\n\t}\n\tif dir == 0 && arr[lo] > arr[lo+cnt-1] {\n\t\tarr[lo], arr[lo+cnt-1] = arr[lo+cnt-1], arr[lo]\n\t}\n}\n\nfunc bitonicSort(arr []int, n, dir int) {\n\tif n > 1 {\n\t\tfor i := 0; i < n; i += 2 {\n\t\t\tbitonicMerge(arr, i, 2, dir)\n\t\t}\n\t\tbitonicSort(arr[:n/2], n/2, 0 if dir == 1 else 1)\n\t\tbitonicSort(arr[n/2:], n/2, 1 if dir == 1 else 0)\n\t}\n}\n\nfunc main() {\n\tarr := []int{8, 1, 2, 3, 7, 6, 5, 4}\n\tbitonicSort(arr, len(arr), 1)\n\tprintln(\"Sorted array is:\", arr)\n}",
    "C": "#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n\nvoid bitonicMerge(int arr[], int lo, int cnt, int dir) {\n\tif (cnt > 1) {\n\t\tint mid = lo + cnt / 2;\n\t\tif (dir == 1) {\n\t\t\tbitonicMerge(arr, lo, cnt / 2, 1);\n\t\t\tbitonicMerge(arr, mid, cnt / 2, 0);\n\t\t} else {\n\t\t\tbitonicMerge(arr, mid, cnt / 2, 0);\n\t\t\tbitonicMerge(arr, lo, cnt / 2, 1);\n\t\t}\n\t}\n\tif (dir == 0 && arr[lo] > arr[lo + cnt - 1]) {\n\t\tswap(&arr[lo], &arr[lo + cnt - 1]);\n\t}\n}\n\nvoid bitonicSort(int arr[], int n, int dir) {\n\tif (n > 1) {\n\t\tfor (int i = 0; i < n; i += 2) {\n\t\t\tbitonicMerge(arr, i, 2, dir);\n\t\t}\n\t\tbitonicSort(arr, n / 2, 0 if dir == 1 else 1);\n\t\tbitonicSort(arr + n / 2, n / 2, 1 if dir == 1 else 0);\n\t}\n}\n\nint main() {\n\tint arr[] = {8, 1, 2, 3, 7, 6, 5, 4};\n\tint n = sizeof(arr) / sizeof(arr[0]);\n\tbitonicSort(arr, n, 1);\n\tprintf(\"Sorted array is: \");\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", arr[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  }
}
