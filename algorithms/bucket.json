{
  "Name": "Bucket Sort",
  "Date": "1960s",
  "Author": "Joseph J. Aiken and Robert Sedgewick",
  "Description": "Bucket sort is a sorting technique that divides the input data into a fixed number of buckets (sub-arrays). Each bucket is then sorted individually using a suitable sorting algorithm like insertion sort. Finally, the sorted buckets are concatenated to form the final sorted output.\n\nThe efficiency of bucket sort heavily relies on choosing the appropriate number of buckets and a sorting algorithm for the buckets. It can be very efficient for data with a uniform distribution within a specific range. However, for skewed distributions or large ranges, bucket sort might require adjustments or become less effective.",
  "Complexity": {
    "Time": "O(n + k)",
    "Best": "O(n + k)",
    "Worst": "O(nÂ² * k)",
    "Space": "O(n + k)",
    "Stable": "Yes"
  },
  "Algorithm": "",
  "Code": {
    "Python": "def bucket_sort(arr):\n\tmax_value = max(arr)\n\tbucket_size = int(max_value / 10) + 1  # Assuming 10 buckets for simplicity\n\tbuckets = [[] for _ in range(bucket_size)]\n\tfor i in arr:\n\t\tindex = i // bucket_size\n\t\tbuckets[index].append(i)\n\tfor i in range(bucket_size):\n\t\tbuckets[i].sort()\n\tresult = []\n\tfor bucket in buckets:\n\t\tresult.extend(bucket)\n\treturn result\n\n# Test array\narr = [8, 3, 2, 7, 4, 6, 9]\nprint('Sorted array is:', bucket_sort(arr))",
    "JavaScript": "function bucketSort(arr) {\n\tlet max_value = Math.max(...arr);\n\tlet bucket_size = Math.floor(max_value / 10) + 1; // Assuming 10 buckets for simplicity\n\tlet buckets = Array(bucket_size).fill([]);\n\tfor (let i of arr) {\n\t\tlet index = Math.floor(i / bucket_size);\n\t\tbuckets[index].push(i);\n\t}\n\tfor (let i = 0; i < bucket_size; i++) {\n\t\tbuckets[i].sort((a, b) => a - b);\n\t}\n\tlet result = [];\n\tfor (let bucket of buckets) {\n\t\tresult.push(...bucket);\n\t}\n\treturn result;\n\t}\n\n// Test array\nlet arr = [8, 3, 2, 7, 4, 6, 9];\nconsole.log('Sorted array is:', bucketSort(arr));",
    "Java": "public static int[] bucketSort(int[] arr) {\n\tint max_value = Integer.MIN_VALUE;\n\tfor (int i : arr) {\n\t\tmax_value = Math.max(max_value, i);\n\t}\n\tint bucket_size = (max_value / 10) + 1; // Assuming 10 buckets for simplicity\n\tList<Integer>[] buckets = new List[bucket_size];\n\tfor (int i = 0; i < bucket_size; i++) {\n\t\tbuckets[i] = new ArrayList<>();\n\t}\n\tfor (int i : arr) {\n\t\tint index = i / bucket_size;\n\t\tbuckets[index].add(i);\n\t}\n\tfor (int i = 0; i < bucket_size; i++) {\n\t\tCollections.sort(buckets[i]); // Sort individual buckets using Collections.sort\n\t}\n\tint index = 0;\n\tint[] sortedArr = new int[arr.length];\n\tfor (List<Integer> bucket : buckets) {\n\t\tfor (int value : bucket) {\n\t\t\tsortedArr[index++] = value;\n\t\t}\n\t}\n\treturn sortedArr;\n\t}\n\n// Test array\nint[] arr = {8, 3, 2, 7, 4, 6, 9};\nSystem.out.println('Sorted array is: ' + Arrays.toString(bucketSort(arr)));",
    "Go": "func bucketSort(arr []int, n int) []int {\n\tbucketSize := n / 10 // Assuming 10 buckets for simplicity\n\tbuckets := make([][]int, bucketSize)\n\tfor _, val := range arr {\n\t\tindex := val / bucketSize\n\t\tbuckets[index] = append(buckets[index], val)\n\t}\n\tfor i := range buckets {\n\t\tsort.Ints(buckets[i]) // Sort individual buckets (using in-built sort) \n\t}\n\tresult := []int{}\n\tfor _, bucket := range buckets {\n\t\tresult = append(result, bucket...)\n\t}\n\treturn result\n\t}\n\n// Test array\narr := []int{8, 3, 2, 7, 4, 6, 9}\nfmt.Println('Sorted array is:', bucketSort(arr, len(arr)))",
    "C": "void bucket_sort(int arr[], int n) {\n\tint max_value = arr[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tmax_value = max(max_value, arr[i]);\n\t}\n\tint bucket_size = n / 10; // Assuming 10 buckets for simplicity\n\tint i, j;\n\tint *buckets[bucket_size];\n\tfor (i = 0; i < bucket_size; ++i) {\n\t\tbuckets[i] = (int *)malloc(n * sizeof(int)); // Allocate memory for each bucket\n\t\tbuckets[i][0] = 0; // Initialize bucket size to 0\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tint index = arr[i] / bucket_size;\n\t\tbuckets[index][++buckets[index][0]] = arr[i]; // Increment size and insert element\n\t}\n\tfor (i = 0; i < bucket_size; i++) {\n\t\tqsort(buckets[i], buckets[i][0], sizeof(int), compare); // Sort individual buckets\n\t\tfree(buckets[i]); // Free allocated memory for each bucket\n\t}\n\ti = 0;\n\tfor (j = 0; j < bucket_size; j++) {\n\t\tfor (int k = 0; k < buckets[j][0]; k++) {\n\t\t\tarr[i++] = buckets[j][k + 1];\n\t\t}\n\t}\n\t}\n\n// Helper function for qsort comparison (assuming qsort is available)\nint compare(const void *a, const void *b) {\n\treturn *(int *)a - *(int *)b;\n}\n\n// Test array\nint arr[] = {8, 3, 2, 7, 4, 6, 9};\nint n = sizeof(arr) / sizeof(arr[0]);\nbucket_sort(arr, n);\nprintf('Sorted array is: ');\nfor (int i = 0; i < n; i++) {\n\tprintf('%d ', arr[i]);\n}"
  }
}
