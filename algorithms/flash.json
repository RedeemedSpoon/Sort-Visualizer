{
  "Name": "Flash Sort",
  "Date": "1998",
  "Author": "Karl-Dietrich Neubert",
  "Description": "Flash sort is a hybrid sorting algorithm that combines the strengths of radix sort and partitioning. It works by creating multiple partitions based on a sample of the input data. Elements are then distributed into these partitions using counting sort. Finally, each partition is sorted individually using insertion sort.\n\nFlash sort is known for its efficiency in specific scenarios and is sometimes used in specialized sorting libraries. However, its complexity depends on factors like the chosen sample size and the distribution of the input data.",
  "Complexity": {
    "Time": "O(n + r)",
    "Best": "O(n)",
    "Worst": "O(nÂ²)",
    "Space": "O(n)",
    "Stable": "No"
  },
  "Algorithm": "async function sort(){const r=Math.max(...array),a=Math.min(...array),e=array.length,t=~~(.45*e),f=new Array(t),n=(t-1)/(array[r]-a);for(let r=0;r<t;r++)f[r]=0;for(let r=0;r<e;++r){++f[~~(n*(array[r]-a))]}for(let r=1;r<t;++r)f[r]=f[r]+f[r-1];if(swap(r - 1,0),await sleep(),firstRun)return;let i,s,o,l=0,y=0,u=t-1;for(;l<e-1;){for(;y>f[u]-1;)++y,u=~~(n*(array[y]-a));if(u<0)break;for(o=array[y];y!==f[u];){if(u=~~(n*(o-a)),swap(y,i=--f[u]),await sleep(),firstRun)return;++l}}for(y=1;y<e;y++){s=array[y];let r=y-1;for(;r>=0&&array[r]>s;){if(swap(r,r+1),await sleep(),firstRun)return;r--}if(swap(r+1,array.indexOf(s)),await sleep(),firstRun)return}}",
  "Code": {
    "Python": "import math\n\ndef flashsort(arr):\n\tn=len(arr)\n\tif n<=1:\n\t\treturn arr\n\n\tmax_val,min_val=max(arr),min(arr)\n\n\trange_val=max_val-min_val\n\tif range_val==0:\n\t\treturn arr\n\tc=int(math.ceil(math.log(n,2)))\n\tm=int(n/c)\n\n\tdist=[0]*m\n\n\tfor i in range(n):\n\t\tbucket=int(m*(arr[i]-min_val)/range_val)\n\t\tdist[bucket]+=1\n\n\tfor i in range(1,m):\n\t\tdist[i]+=dist[i-1]\n\n\tc_ptr=[0]*m\n\tfor i in range(n):\n\t\tbucket=int(m*(arr[i]-min_val)/range_val)\n\t\tc_ptr[bucket]-=1\n\t\ttemp=arr[i]\n\t\tarr[dist[bucket]+c_ptr[bucket]]=temp\n\n\tfor i in range(m-1):\n\t\tstart=dist[i]\n\t\tend=dist[i+1]\n\t\tfor j in range(start+1,end):\n\t\t\ttemp=arr[j]\n\t\t\tk=j-1\n\t\t\twhile k>=start and arr[k]>temp:\n\t\t\t\tarr[k+1]=arr[k]\n\t\t\t\tk-=1\n\t\t\tarr[k+1]=temp\n\n\treturn arr",
    "JavaScript": "function flashsort(arr) {\n\tlet n = arr.length;\n\tif (n <= 1) {\n\t\treturn arr;\n\t}\n\n\tlet maxVal = Math.max(...arr);\n\tlet minVal = Math.min(...arr);\n\n\tlet rangeVal = maxVal - minVal;\n\tif (rangeVal === 0) {\n\t\treturn arr;\n\t}\n\tlet c = Math.ceil(Math.log2(n));\n\tlet m = Math.floor(n / c);\n\n\tlet dist = new Array(m).fill(0);\n\n\tfor (let i = 0; i < n; i++) {\n\t\tlet bucket = Math.floor(m * (arr[i] - minVal) / rangeVal);\n\t\tdist[bucket]++;\n\t}\n\n\tfor (let i = 1; i < m; i++) {\n\t\tdist[i] += dist[i - 1];\n\t}\n\n\tlet cPtr = new Array(m).fill(0);\n\tfor (let i = 0; i < n; i++) {\n\t\tlet bucket = Math.floor(m * (arr[i] - minVal) / rangeVal);\n\t\tcPtr[bucket]--;\n\t\tlet temp = arr[i];\n\t\tarr[dist[bucket] + cPtr[bucket]] = temp;\n\t}\n\n\tfor (let i = 0; i < m - 1; i++) {\n\t\tlet start = dist[i];\n\t\tlet end = dist[i + 1];\n\t\tfor (let j = start + 1; j < end; j++) {\n\t\t\tlet temp = arr[j];\n\t\t\tlet k = j - 1;\n\t\t\twhile (k >= start && arr[k] > temp) {\n\t\t\t\tarr[k + 1] = arr[k];\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tarr[k + 1] = temp;\n\t\t}\n\t}\n\n\treturn arr;\n}",
    "Java": "import java.util.Arrays;\n\npublic class FlashSort {\n\tpublic static void flashsort(int[] arr) {\n\t\tint n = arr.length;\n\t\tif (n <= 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tint maxVal = Arrays.stream(arr).max().getAsInt();\n\t\tint minVal = Arrays.stream(arr).min().getAsInt();\n\n\t\tint rangeVal = maxVal - minVal;\n\t\tif (rangeVal == 0) {\n\t\t\treturn;\n\t\t}\n\t\tint c = (int) Math.ceil(Math.log(n) / Math.log(2));\n\t\tint m = n / c;\n\n\t\tint[] dist = new int[m];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint bucket = (int) (m * (arr[i] - minVal) / rangeVal);\n\t\t\tdist[bucket]++;\n\t\t}\n\n\t\tfor (int i = 1; i < m; i++) {\n\t\t\tdist[i] += dist[i - 1];\n\t\t}\n\n\t\tint[] cPtr = new int[m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint bucket = (int) (m * (arr[i] - minVal) / rangeVal);\n\t\t\tcPtr[bucket]--;\n\t\t\tint temp = arr[i];\n\t\t\tarr[dist[bucket] + cPtr[bucket]] = temp;\n\t\t}\n\n\t\tfor (int i = 0; i < m - 1; i++) {\n\t\t\tint start = dist[i];\n\t\t\tint end = dist[i + 1];\n\t\t\tfor (int j = start + 1; j < end; j++) {\n\t\t\t\tint temp = arr[j];\n\t\t\t\tint k = j - 1;\n\t\t\t\twhile (k >= start && arr[k] > temp) {\n\t\t\t\t\tarr[k + 1] = arr[k];\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tarr[k + 1] = temp;\n\t\t\t}\n\t\t}\n\t}\n}",
    "Go": "package main\n\nimport (\n\t\"math\"\n\t\"sort\"\n)\n\nfunc flashsort(arr []int) []int {\n\tif len(arr) <= 1 {\n\t\treturn arr\n\t}\n\n\tmaxVal, minVal := arr[0], arr[0]\n\tfor _, v := range arr {\n\t\tif v > maxVal {\n\t\t\tmaxVal = v\n\t\t}\n\t\tif v < minVal {\n\t\t\tminVal = v\n\t\t}\n\t}\n\n\trangeVal := maxVal - minVal\n\tif rangeVal == 0 {\n\t\treturn arr\n\t}\n\tc := int(math.Ceil(math.Log2(float64(len(arr)))))\n\tm := len(arr) / c\n\n\tdist := make([]int, m)\n\n\tfor _, v := range arr {\n\t\tbucket := int(float64(m) * float64(v-minVal) / float64(rangeVal))\n\t\tdist[bucket]++\n\t}\n\n\tfor i := 1; i < m; i++ {\n\t\tdist[i] += dist[i-1]\n\t}\n\n\tcPtr := make([]int, m)\n\tfor i, v := range arr {\n\t\tbucket := int(float64(m) * float64(v-minVal) / float64(rangeVal))\n\t\tcPtr[bucket]--\n\t\tarr[dist[bucket]+cPtr[bucket]] = v\n\t}\n\n\tfor i := 0; i < m-1; i++ {\n\t\tstart := dist[i]\n\t\tend := dist[i+1]\n\t\tsort.Ints(arr[start:end])\n\t}\n\n\treturn arr\n}",
    "C": "#include <stdio.h>\n#include <math.h>\n\nvoid flashsort(int arr[], int n) {\n\tif (n <= 1) {\n\t\treturn;\n\t}\n\n\tint maxVal = arr[0], minVal = arr[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tif (arr[i] > maxVal) {\n\t\t\tmaxVal = arr[i];\n\t\t}\n\t\tif (arr[i] < minVal) {\n\t\t\tminVal = arr[i];\n\t\t}\n\t}\n\n\tint rangeVal = maxVal - minVal;\n\tif (rangeVal == 0) {\n\t\treturn;\n\t}\n\tint c = (int) ceil(log2(n));\n\tint m = n / c;\n\n\tint dist[m] = {0};\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint bucket = (int) (m * (arr[i] - minVal) / rangeVal);\n\t\tdist[bucket]++;\n\t}\n\n\tfor (int i = 1; i < m; i++) {\n\t\tdist[i] += dist[i - 1];\n\t}\n\n\tint cPtr[m] = {0};\n\tfor (int i = 0; i < n; i++) {\n\t\tint bucket = (int) (m * (arr[i] - minVal) / rangeVal);\n\t\tcPtr[bucket]--;\n\t\tint temp = arr[i];\n\t\tarr[dist[bucket] + cPtr[bucket]] = temp;\n\t}\n\n\tfor (int i = 0; i < m - 1; i++) {\n\t\tint start = dist[i];\n\t\tint end = dist[i + 1];\n\t\tfor (int j = start + 1; j < end; j++) {\n\t\t\tint temp = arr[j];\n\t\t\tint k = j - 1;\n\t\t\twhile (k >= start && arr[k] > temp) {\n\t\t\t\tarr[k + 1] = arr[k];\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tarr[k + 1] = temp;\n\t\t}\n\t}\n}"
  }
}
