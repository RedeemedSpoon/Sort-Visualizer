{
  "Name": "Heap Sort",
  "Date": "1964",
  "Author": "J. W. J. Williams",
  "Description": "Heap sort is a sorting algorithm that utilizes a heap data structure for efficient element arrangement. It follows a divide-and-conquer approach, initially building a max-heap (where the root has the largest value) from the input array. This process involves repeatedly swapping elements to ensure the heap property holds (parent element greater than or equal to children).\n\nOnce the max-heap is constructed, the largest element (root) is extracted and placed at the end of the sorted array. The heap is then rearranged by swapping the root with the last element and restoring the heap property. This process of extraction, rearrangement, and swapping continues until the entire array is sorted in descending order. For ascending order, a min-heap (root has the smallest value) would be used.",
  "Complexity": {
    "Time": "O(n log n)",
    "Best": "O(n log n)",
    "Worst": "O(n log n)",
    "Space": "O(1)",
    "Stable": "No"
  },
  "Algorithm": "async function sort(){async function a(r,t){let n=r;const i=2*r+1,e=2*r+2;if(i<t&&array[i]>array[n]&&(n=i),e<t&&array[e]>array[n]&&(n=e),n!==r){if(firstRun)return;swap(r,n),await sleep(),await a(n,t)}}await async function(){for(let r=Math.floor(array.length/2)-1;r>=0;r--)await a(r,array.length)}(array);for(let r=array.length-1;r>0;r--){if(firstRun)return;swap(0,r),await sleep(),await a(0,r)}}",
  "Code": {
    "Python": "def heapify(arr, n, i):\n\tlargest = i  # Initialize largest as root\n\tlf = 2 * i + 1  # left = 2*i + 1\n\tright = 2 * i + 2  # right = 2*i + 2\n\n\t# See if left child is larger than root\n\tif lf < n and arr[i] < arr[lf]:\n\t\tlargest = lf\n\n\t# See if right child is larger\n\tif right < n and arr[largest] < arr[right]:\n\t\tlargest = right\n\n\t# Swap if largest is not root\n\tif largest != i:\n\t\tarr[i], arr[largest] = arr[largest], arr[i]\n\t\theapify(arr, n, largest)\n\ndef heap_sort(arr):\n\tn = len(arr)\n\n\t# Build a maxheap.\n\tfor i in range(n // 2 - 1, -1, -1):\n\t\theapify(arr, n, i)\n\n\t# One by one extract an element from heap\n\tfor i in range(n - 1, 0, -1):\n\t\tarr[i], arr[0] = arr[0], arr[i]  # swap\n\t\theapify(arr, i, 0)  # reduce heap size and maintain heap property\n\n# Test array\narr = [12, 11, 13, 5, 6, 7]\nheap_sort(arr)\nprint('Sorted array is:', arr)",
    "JavaScript": "function heapify(arr, n, i) {\n\tlet largest = i;  // Initialize largest as root\n\tlet left = 2 * i + 1;  // left = 2*i + 1\n\tlet right = 2 * i + 2;  // right = 2*i + 2\n\n\t// See if left child is larger than root\n\tif (left < n && arr[i] < arr[left]) {\n\t\tlargest = left;\n\t}\n\n\t// See if right child is larger\n\tif (right < n && arr[largest] < arr[right]) {\n\t\tlargest = right;\n\t}\n\n\t// Swap if largest is not root\n\tif (largest !== i) {\n\t\tlet temp = arr[i];\n\t\tarr[i] = arr[largest];\n\t\tarr[largest] = temp;\n\t\theapify(arr, n, largest);\n\t}\n}\n\nfunction heapSort(arr) {\n\tlet n = arr.length;\n\n\t// Build a maxheap.\n\tfor (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n\t\theapify(arr, n, i);\n\t}\n\n\t// One by one extract an element from heap\n\tfor (let i = n - 1; i > 0; i--) {\n\t\t// Move current root to end\n\t\tlet temp = arr[0];\n\t\tarr[0] = arr[i];\n\t\tarr[i] = temp;\n\t\theapify(arr, i, 0);\n\t}\n}\n\n// Test array\nlet arr = [12, 11, 13, 5, 6, 7];\nheapSort(arr);\nconsole.log('Sorted array is:', arr);",
    "Java": "public class HeapSort {\n\tpublic static void heapify(int arr[], int n, int i) {\n\t\tint largest = i; // Initialize largest as root\n\t\tint left = 2 * i + 1; // left = 2*i + 1\n\t\tint right = 2 * i + 2; // right = 2*i + 2\n\n\t\t// See if left child is larger than root\n\t\tif (left < n && arr[i] < arr[left]) {\n\t\t\tlargest = left;\n\t\t}\n\n\t\t// See if right child is larger\n\t\tif (right < n && arr[largest] < arr[right]) {\n\t\t\tlargest = right;\n\t\t}\n\n\t\t// Swap if largest is not root\n\t\tif (largest != i) {\n\t\t\tint temp = arr[i];\n\t\t\tarr[i] = arr[largest];\n\t\t\tarr[largest] = temp;\n\t\t\theapify(arr, n, largest);\n\t\t}\n\t}\n\n\tpublic static void heapSort(int arr[]) {\n\t\tint n = arr.length;\n\n\t\t// Build a maxheap.\n\t\tfor (int i = n / 2 - 1; i >= 0; i--) {\n\t\t\theapify(arr, n, i);\n\t\t}\n\n\t\t// One by one extract an element from heap\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\t// Move current root to end\n\t\t\tint temp = arr[0];\n\t\t\tarr[0] = arr[i];\n\t\t\tarr[i] = temp;\n\t\t\theapify(arr, i, 0);\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tint arr[] = {12, 11, 13, 5, 6, 7};\n\t\theapSort(arr);\n\n\t\tSystem.out.println(\"Sorted array is: \");\n\t\tfor (int i = 0; i < arr.length; ++i) {\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\t}\n\t}\n}",
    "Go": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc heapify(arr []int, n int, i int) {\n\tlargest := i  // Initialize largest as root\n\tleft := 2*i + 1  // left = 2*i + 1\n\tright := 2*i + 2 // right = 2*i + 2\n\n\t// See if left child is larger than root\n\tif left < n && arr[i] < arr[left] {\n\t\tlargest = left\n\t}\n\n\t// See if right child is larger\n\tif right < n && arr[largest] < arr[right] {\n\t\tlargest = right\n\t}\n\n\t// Swap if largest is not root\n\tif largest != i {\n\t\tarr[i], arr[largest] = arr[largest], arr[i]\n\t\theapify(arr, n, largest)\n\t}\n}\n\nfunc heapSort(arr []int) {\n\tn := len(arr)\n\n\t// Build a maxheap.\n\tfor i := n/2 - 1; i >= 0; i-- {\n\t\theapify(arr, n, i)\n\t}\n\n\t// One by one extract an element from heap\n\tfor i := n - 1; i > 0; i-- {\n\t\t// Move current root to end\n\t\tarr[0], arr[i] = arr[i], arr[0]\n\t\theapify(arr, i, 0)\n\t}\n}\n\nfunc main() {\n\tarr := []int{12, 11, 13, 5, 6, 7}\n\theapSort(arr)\n\n\tfmt.Println(\"Sorted array is: \", arr)\n}\n",
    "C": "#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n\nvoid heapify(int arr[], int n, int i) {\n\tint largest = i; // Initialize largest as root\n\tint left = 2 * i + 1; // left = 2*i + 1\n\tint right = 2 * i + 2; // right = 2*i + 2\n\n\t// See if left child is larger than root\n\tif (left < n && arr[i] < arr[left]) {\n\t\tlargest = left;\n\t}\n\n\t// See if right child is larger\n\tif (right < n && arr[largest] < arr[right]) {\n\t\tlargest = right;\n\t}\n\n\t// Swap if largest is not root\n\tif (largest != i) {\n\t\tswap(&arr[i], &arr[largest]);\n\t\theapify(arr, n, largest);\n\t}\n}\n\nvoid heapSort(int arr[], int n) {\n\t// Build a maxheap.\n\tfor (int i = n / 2 - 1; i >= 0; i--) {\n\t\theapify(arr, n, i);\n\t}\n\n\t// One by one extract an element from heap\n\tfor (int i = n - 1; i > 0; i--) {\n\t\t// Move current root to end\n\t\tswap(&arr[0], &arr[i]);\n\t\theapify(arr, i, 0);\n\t}\n}\n\nint main() {\n\tint arr[] = {12, 11, 13, 5, 6, 7};\n\tint n = sizeof(arr) / sizeof(arr[0]);\n\theapSort(arr, n);\n\tprintf(\"Sorted array is: \");\n\tfor (int i = 0; i < n; ++i) {\n\t\tprintf(\"%d \", arr[i]);\n\t};\n\n\treturn 0;\n}"
  }
}
