{
  "Name": "Merge Sort",
  "Date": "1945",
  "Author": "John von Neumann",
  "Description": "Merge sort is another divide-and-conquer algorithm that excels in sorting linked lists or arrays. It works by recursively dividing the input data structure into smaller sub-arrays containing a single element each (base case).\n\nIn the merge phase, adjacent sub-arrays are combined while maintaining the sorted order. This is achieved by comparing elements from both sub-arrays and inserting the smaller one into the final merged sub-array. This process continues until all sub-arrays are merged into a single sorted array.",
  "Complexity": {
    "Time": "O(n log n)",
    "Best": "O(n log n)",
    "Worst": "O(n log n)",
    "Space": "O(n)",
    "Stable": "Yes"
  },
  "Algorithm": "",
  "Code": {
    "Python": "def merge(arr, l, m, r):\n\tlen1 = m - l + 1\n\tlen2 = r - m\n\tLeft = [0] * (len1)\n\tRight = [0] * (len2)\n\n\tfor i in range(0 , len1):\n\t\tLeft[i] = arr[l + i]\n\tfor j in range(0 , len2):\n\t\tRight[j] = arr[m + 1 + j]\n\n\ti = 0\n\tj = 0\n\tk = l\n\n\twhile i < len1 and j < len2 :\n\t\tif Left[i] <= Right[j]:\n\t\t\tarr[k] = Left[i]\n\t\t\ti += 1\n\t\telse:\n\t\t\tarr[k] = Right[j]\n\t\t\tj += 1\n\t\tk += 1\n\n\twhile i < len1:\n\t\tarr[k] = Left[i]\n\t\ti += 1\n\t\tk += 1\n\n\twhile j < len2:\n\t\tarr[k] = Right[j]\n\t\tj += 1\n\t\tk += 1\n\ndef mergeSort(arr, l, r):\n\tif l < r:\n\t\tm = l+(r-l)//2\n\n\t\tmergeSort(arr, l, m)\n\t\tmergeSort(arr, m+1, r)\n\t\tmerge(arr, l, m, r)\n\n# Test array\narr = [12, 11, 13, 5, 6, 7]\nmergeSort(arr,0,len(arr)-1)\nprint('Sorted array is:', arr)",
    "JavaScript": "function merge(arr, left, mid, right) {\n\tlet n1 = mid - left + 1;\n\tlet n2 = right - mid;\n\tlet leftArr = new Array(n1);\n\tlet rightArr = new Array(n2);\n\n\tfor (let i = 0; i < n1; i++)\n\t\tleftArr[i] = arr[left + i];\n\tfor (let j = 0; j < n2; j++)\n\t\trightArr[j] = arr[mid + 1 + j];\n\n\tlet i = 0;\n\tlet j = 0;\n\tlet k = left;\n\n\twhile (i < n1 && j < n2) {\n\t\tif (leftArr[i] <= rightArr[j]) {\n\t\t\tarr[k] = leftArr[i];\n\t\t\ti++;\n\t\t} else {\n\t\t\tarr[k] = rightArr[j];\n\t\t\tj++;\n\t\t}\n\t\tk++;\n\t}\n\n\twhile (i < n1) {\n\t\tarr[k] = leftArr[i];\n\t\ti++;\n\t\tk++;\n\t}\n\n\twhile (j < n2) {\n\t\tarr[k] = rightArr[j];\n\t\tj++;\n\t\tk++;\n\t}\n}\n\nfunction mergeSort(arr, left, right) {\n\tif (left < right) {\n\t\tlet mid = Math.floor(left + (right - left) / 2);\n\n\t\tmergeSort(arr, left, mid);\n\t\tmergeSort(arr, mid + 1, right);\n\t\tmerge(arr, left, mid, right);\n\t}\n}\n",
    "Java": "public class MergeSort {\n\tpublic static void merge(int arr[], int l, int m, int r) {\n\t\tint n1 = m - l + 1;\n\t\tint n2 = r - m;\n\t\tint Left[] = new int[n1];\n\t\tint Right[] = new int[n2];\n\n\t\tfor (int i = 0; i < n1; i++)\n\t\t\tLeft[i] = arr[l + i];\n\t\tfor (int j = 0; j < n2; j++)\n\t\t\tRight[j] = arr[m + 1 + j];\n\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = l;\n\n\t\twhile (i < n1 && j < n2) {\n\t\t\tif (Left[i] <= Right[j]) {\n\t\t\t\tarr[k] = Left[i];\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tarr[k] = Right[j];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\twhile (i < n1) {\n\t\t\tarr[k] = Left[i];\n\t\t\ti++;\n\t\t\tk++;\n\t\t}\n\n\t\twhile (j < n2) {\n\t\t\tarr[k] = Right[j];\n\t\t\tj++;\n\t\t\tk++;\n\t\t}\n\t}\n\n\tpublic static void mergeSort(int arr[], int left, int right) {\n\t\tif (left < right) {\n\t\t\tint mid = left + (right - left) / 2;\n\n\t\t\tmergeSort(arr, left, mid);\n\t\t\tmergeSort(arr, mid + 1, right);\n\t\t\tmerge(arr, left, mid, right);\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tint arr[] = {12, 11, 13, 5, 6, 7};\n\t\tint n = arr.length;\n\n\t\tSystem.out.println(\"Unsorted array is \");\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\n\t\tmergeSort(arr, 0, n - 1);\n\n\t\tSystem.out.println(\"\nSorted array is \");\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t}\n}",
    "Go": "func merge(arr []int, left int, mid int, right int) {\n\tn1 := mid - left + 1\n\tn2 := right - mid\n\tleftArr := make([]int, n1)\n\trightArr := make([]int, n2)\n\n\tfor i := 0; i < n1; i++ {\n\t\tleftArr[i] = arr[left+i]\n\t}\n\tfor j := 0; j < n2; j++ {\n\t\trightArr[j] = arr[mid+1+j]\n\t}\n\n\ti := 0\n\tj := 0\n\tk := left\n\n\tfor i < n1 && j < n2 {\n\t\tif leftArr[i] <= rightArr[j] {\n\t\t\tarr[k] = leftArr[i]\n\t\t\ti++\n\t\t} else {\n\t\t\tarr[k] = rightArr[j]\n\t\t\tj++\n\t\t}\n\t\tk++\n\t}\n\n\tfor i < n1 {\n\t\tarr[k] = leftArr[i]\n\t\ti++\n\t\tk++\n\t}\n\n\tfor j < n2 {\n\t\tarr[k] = rightArr[j]\n\t\tj++\n\t\tk++\n\t}\n}\n\nfunc mergeSort(arr []int, left int, right int) {\n\tif left < right {\n\t\tmid := left + (right - left) / 2\n\n\t\tmergeSort(arr, left, mid)\n\t\tmergeSort(arr, mid + 1, right)\n\t\tmerge(arr, left, mid, right)\n\t}\n}\n",
    "C": "void merge(int arr[], int l, int m, int r) {\n\tint n1 = m - l + 1;\n\tint n2 = r - m;\n\tint leftArr[n1], rightArr[n2];\n\n\tfor (int i = 0; i < n1; i++)\n\t\tleftArr[i] = arr[l + i];\n\tfor (int j = 0; j < n2; j++)\n\t\trightArr[j] = arr[m + 1 + j];\n\n\tint i = 0;\n\tint j = 0;\n\tint k = l;\n\n\twhile (i < n1 && j < n2) {\n\t\tif (leftArr[i] <= rightArr[j]) {\n\t\t\tarr[k] = leftArr[i];\n\t\t\ti++;\n\t\t} else {\n\t\t\tarr[k] = rightArr[j];\n\t\t\tj++;\n\t\t}\n\t\tk++;\n\t}\n\n\twhile (i < n1) {\n\t\tarr[k] = leftArr[i];\n\t\ti++;\n\t\tk++;\n\t}\n\n\twhile (j < n2) {\n\t\tarr[k] = rightArr[j];\n\t\tj++;\n\t\tk++;\n\t}\n}\n\nvoid mergeSort(int arr[], int left, int right) {\n\tif (left < right) {\n\t\tint mid = left + (right - left) / 2;\n\n\t\tmergeSort(arr, left, mid);\n\t\tmergeSort(arr, mid + 1, right);\n\t\tmerge(arr, left, mid, right);\n\t}\n}\n"
  }
}
