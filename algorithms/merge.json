{
  "Name": "Merge Sort",
  "Date": "1945",
  "Author": "John von Neumann",
  "Description": "Merge sort is another divide-and-conquer algorithm that excels in sorting linked lists or arrays. It works by recursively dividing the input data structure into smaller sub-arrays containing a single element each (base case).\n\nIn the merge phase, adjacent sub-arrays are combined while maintaining the sorted order. This is achieved by comparing elements from both sub-arrays and inserting the smaller one into the final merged sub-array. This process continues until all sub-arrays are merged into a single sorted array.",
  "Complexity": {
    "Time": "O(n log n)",
    "Best": "O(n log n)",
    "Worst": "O(n log n)",
    "Space": "O(n)",
    "Stable": "Yes"
  },
  "Algorithm": "async function sort(){await async function a(r,t,e){if(t<e){let i=t+Math.floor((e-t)/2);await a(r,t,i),await a(r,i+1,e),await async function(a,r,t,e){let i=t-r+1,n=e-t,f=new Array(i),s=new Array(n);for(let t=0;t<i;t++)f[t]=a[r+t];for(let r=0;r<n;r++)s[r]=a[t+1+r];let w=0,l=0,o=r;for(;w<i&&l<n;){if(f[w]<=s[l]){if(a[o]=f[w],firstRun)return;swap(o,array.indexOf(f[w])),await sleep(),w++}else{if(a[o]=s[l],firstRun)return;swap(o,array.indexOf(s[l])),await sleep(),l++}o++}for(;w<i;){if(a[o]=f[w],firstRun)return;swap(o,array.indexOf(f[w])),await sleep(),w++,o++}for(;l<n;){if(a[o]=s[l],firstRun)return;swap(o,array.indexOf(s[l])),await sleep(),l++,o++}}(r,t,i,e)}}([...array],0,array.length-1)}",
  "Code": {
    "Python": "def merge(arr, left, mid, right):\n\tn1 = mid - left + 1\n\tn2 = right - mid\n\n\tleft_arr = [0] * n1\n\tright_arr = [0] * n2\n\n\tfor i in range(0, n1):\n\t\tleft_arr[i] = arr[left + i]\n\tfor j in range(0, n2):\n\t\tright_arr[j] = arr[mid + 1 + j]\n\n\ti = 0\n\tj = 0\n\tk = left\n\n\twhile i < n1 and j < n2:\n\t\tif left_arr[i] <= right_arr[j]:\n\t\t\tarr[k] = left_arr[i]\n\t\t\ti += 1\n\t\telse:\n\t\t\tarr[k] = right_arr[j]\n\t\t\tj += 1\n\t\tk += 1\n\n\twhile i < n1:\n\t\tarr[k] = left_arr[i]\n\t\ti += 1\n\t\tk += 1\n\n\twhile j < n2:\n\t\tarr[k] = right_arr[j]\n\t\tj += 1\n\t\tk += 1\n\ndef merge_sort(arr, left, right):\n\tif left < right:\n\t\tm = left + (right - left) // 2\n\t\tmerge_sort(arr, left, m)\n\t\tmerge_sort(arr, m + 1, right)\n\t\tmerge(arr, left, m, right)\n\n# Test array\narr = [12, 11, 13, 5, 6, 7]\nmerge_sort(arr, 0, len(arr) - 1)\nprint('Sorted array is:', arr)",
    "JavaScript": "function merge(arr, left, mid, right) {\n\tlet n1 = mid - left + 1;\n\tlet n2 = right - mid;\n\n\tlet leftArr = new Array(n1);\n\tlet rightArr = new Array(n2);\n\n\tfor (let i = 0; i < n1; i++) {\n\t\tleftArr[i] = arr[left + i];\n\t}\n\tfor (let j = 0; j < n2; j++) {\n\t\trightArr[j] = arr[mid + 1 + j];\n\t}\n\n\tlet i = 0;\n\tlet j = 0;\n\tlet k = left;\n\n\twhile (i < n1 && j < n2) {\n\t\tif (leftArr[i] <= rightArr[j]) {\n\t\t\tarr[k] = leftArr[i];\n\t\t\ti++;\n\t\t} else {\n\t\t\tarr[k] = rightArr[j];\n\t\t\tj++;\n\t\t}\n\t\tk++;\n\t}\n\n\twhile (i < n1) {\n\t\tarr[k] = leftArr[i];\n\t\ti++;\n\t\tk++;\n\t}\n\n\twhile (j < n2) {\n\t\tarr[k] = rightArr[j];\n\t\tj++;\n\t\tk++;\n\t}\n}\n\nfunction mergeSort(arr, left, right) {\n\tif (left < right) {\n\t\tlet m = left + Math.floor((right - left) / 2);\n\t\tmergeSort(arr, left, m);\n\t\tmergeSort(arr, m + 1, right);\n\t\tmerge(arr, left, m, right);\n\t}\n}\n\n// Test array\nlet arr = [12, 11, 13, 5, 6, 7];\nmergeSort(arr, 0, arr.length - 1);\nconsole.log('Sorted array is:', arr);",
    "Java": "public class MergeSort {\n\tpublic static void merge(int[] arr, int left, int mid, int right) {\n\t\tint n1 = mid - left + 1;\n\t\tint n2 = right - mid;\n\n\t\tint[] leftArr = new int[n1];\n\t\tint[] rightArr = new int[n2];\n\n\t\tfor (int i = 0; i < n1; i++) {\n\t\t\tleftArr[i] = arr[left + i];\n\t\t}\n\t\tfor (int j = 0; j < n2; j++) {\n\t\t\trightArr[j] = arr[mid + 1 + j];\n\t\t}\n\n\t\tint i = 0, j = 0, k = left;\n\t\twhile (i < n1 && j < n2) {\n\t\t\tif (leftArr[i] <= rightArr[j]) {\n\t\t\t\tarr[k] = leftArr[i];\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tarr[k] = rightArr[j];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\twhile (i < n1) {\n\t\t\tarr[k] = leftArr[i];\n\t\t\ti++;\n\t\t\tk++;\n\t\t}\n\n\t\twhile (j < n2) {\n\t\t\tarr[k] = rightArr[j];\n\t\t\tj++;\n\t\t\tk++;\n\t\t}\n\t}\n\n\tpublic static void mergeSort(int[] arr, int left, int right) {\n\t\tif (left < right) {\n\t\t\tint mid = left + (right - left) / 2;\n\t\t\tmergeSort(arr, left, mid);\n\t\t\tmergeSort(arr, mid + 1, right);\n\t\t\tmerge(arr, left, mid, right);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint[] arr = {12, 11, 13, 5, 6, 7};\n\t\tmergeSort(arr, 0, arr.length - 1);\n\n\t\tSystem.out.print(\"Sorted array is: \");\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\t}\n\t}\n}",
    "Go": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc merge(arr []int, left, mid, right int) {\n\tn1 := mid - left + 1\n\tn2 := right - mid\n\n\tleftArr := make([]int, n1)\n\trightArr := make([]int, n2)\n\n\tcopy(leftArr, arr[left:left+n1])\n\tcopy(rightArr, arr[mid+1:right+1])\n\n\ti := 0\n\tj := 0\n\tk := left\n\n\tfor i < n1 && j < n2 {\n\t\tif leftArr[i] <= rightArr[j] {\n\t\t\tarr[k] = leftArr[i]\n\t\t\ti++\n\t\t} else {\n\t\t\tarr[k] = rightArr[j]\n\t\t\tj++\n\t\t}\n\t\tk++\n\t}\n\n\tfor i < n1 {\n\t\tarr[k] = leftArr[i]\n\t\t\ti++\n\t\tk++\n\t}\n\n\tfor j < n2 {\n\t\tarr[k] = rightArr[j]\n\t\t\tj++\n\t\tk++\n\t}\n}\n\nfunc mergeSort(arr []int, left, right int) {\n\tif left < right {\n\t\tm := left + (right-left)/2\n\t\tmergeSort(arr, left, m)\n\t\tmergeSort(arr, m+1, right)\n\t\tmerge(arr, left, m, right)\n\t}\n}\n\nfunc main() {\n\tarr := []int{12, 11, 13, 5, 6, 7}\n\tmergeSort(arr, 0, len(arr)-1)\n\n\tfmt.Println(\"Sorted array is: \", arr)\n}",
    "C": "#include <stdio.h>\n\nvoid merge(int arr[], int left, int mid, int right) {\n\tint n1 = mid - left + 1;\n\tint n2 = right - mid;\n\n\tint leftArr[n1], rightArr[n2];\n\n\tfor (int i = 0; i < n1; i++) {\n\t\tleftArr[i] = arr[left + i];\n\t}\n\tfor (int j = 0; j < n2; j++) {\n\t\trightArr[j] = arr[mid + 1 + j];\n\t}\n\n\tint i = 0, j = 0, k = left;\n\n\twhile (i < n1 && j < n2) {\n\t\tif (leftArr[i] <= rightArr[j]) {\n\t\t\tarr[k] = leftArr[i];\n\t\t\ti++;\n\t\t} else {\n\t\t\tarr[k] = rightArr[j];\n\t\t\tj++;\n\t\t}\n\t\tk++;\n\t}\n\n\twhile (i < n1) {\n\t\tarr[k] = leftArr[i];\n\t\t\ti++;\n\t\tk++;\n\t}\n\n\twhile (j < n2) {\n\t\tarr[k] = rightArr[j];\n\t\t\tj++;\n\t\tk++;\n\t}\n}\n\nvoid mergeSort(int arr[], int left, int right) {\n\tif (left < right) {\n\t\tint mid = left + (right - left) / 2;\n\t\tmergeSort(arr, left, mid);\n\t\tmergeSort(arr, mid + 1, right);\n\t\tmerge(arr, left, mid, right);\n\t}\n}\n\nint main() {\n\tint arr[] = {12, 11, 13, 5, 6, 7};\n\tint n = sizeof(arr) / sizeof(arr[0]);\n\tmergeSort(arr, 0, n - 1);\n\tprintf(\"Sorted array is: \");\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", arr[i]);\n\t}\n\treturn 0;\n"
  }
}
