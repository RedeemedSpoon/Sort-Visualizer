{
  "Name": "Pancake Sorting",
  "Date": "1970s",
  "Author": "Jacob Eli Goodman",
  "Description": "Pancake sort, despite its intriguing name, operates on a more theoretical level. It envisions an array of elements like pancakes on a griddle. The algorithm involves 'flipping' subsequences within the array to bring the largest element to the end. This process is repeated, progressively reducing the unsorted portion of the array.\n\nPancake sort has a worst-case time complexity of O(n²) but finds application in some theoretical computer science problems. However, due to its flipping operation being impractical for most real-world implementations, it's not commonly used for practical sorting tasks.",
  "Complexity": {
    "Time": "O(n²)",
    "Best": "O(n)",
    "Worst": "O(n²)",
    "Space": "O(1)",
    "Stable": "No"
  },
  "Algorithm": "async function sort(){for(let a=array.length;a>1;--a){let i=array.indexOf(Math.max(...array.slice(0,a)));if(i!=a-1){if(await flip(0,i),firstRun)return;if(await flip(0,a-1),firstRun)return}}}",
  "Code": {
    "Python": "def pancakesort(arr):\n\tn = len(arr)\n\twhile n > 1:\n\t\t# Find index of the maximum element in the unsorted part\n\t\tmax_index = arr.index(max(arr[:n]))\n\t\t# Flip elements from the beginning to the index of the maximum element\n\t\tarr = arr[:max_index + 1][::-1] + arr[max_index + 1:]\n\t\t# Flip elements from the beginning to the new end (excluding the maximum element)\n\t\tarr = arr[:n][::-1] + arr[n:]\n\t\tn -= 1  # Reduce the unsorted part\n\n# Test array\narr = [3, 2, 4, 1]\npancakesort(arr)\nprint('Sorted array is:', arr)",
    "JavaScript": "function pancakesort(arr) {\n\tlet n = arr.length;\n\twhile (n > 1) {\n\t\t// Find index of the maximum element in the unsorted part\n\t\tlet maxIndex = arr.indexOf(Math.max(...arr.slice(0, n)));\n\t\t// Flip elements from the beginning to the index of the maximum element\n\t\tarr.splice(0, maxIndex + 1).reverse();\n\t\t// Flip elements from the beginning to the new end (excluding the maximum element)\n\t\tarr.splice(0, n).reverse();\n\t\tn--;  // Reduce the unsorted part\n\t}\n\n\t// Test array\n\tlet arr = [3, 2, 4, 1];\n\tpancakesort(arr);\n\tconsole.log('Sorted array is:', arr);\n}",
    "Java": "public static void pancakesort(int[] arr) {\n\tint n = arr.length;\n\twhile (n > 1) {\n\t\t// Find index of the maximum element in the unsorted part\n\t\tint maxIndex = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr[i] > arr[maxIndex]) {\n\t\t\t\tmaxIndex = i;\n\t\t\t}\n\t\t}\n\t\t// Flip elements from the beginning to the index of the maximum element\n\t\treverse(arr, 0, maxIndex);\n\t\t// Flip elements from the beginning to the new end (excluding the maximum element)\n\t\treverse(arr, 0, n - 1);\n\t\tn--;  // Reduce the unsorted part\n\t}\n\n\t// Helper function for reversing a subarray\n\tprivate static void reverse(int[] arr, int start, int end) {\n\t\twhile (start < end) {\n\t\t\tint temp = arr[start];\n\t\t\tarr[start] = arr[end];\n\t\t\tarr[end] = temp;\n\t\t\tstart++;\n\t\t\tend--;\n\t\t}\n\t}\n\n\t// Test array\n\tint[] arr = {3, 2, 4, 1};\n\tpancakesort(arr);\n\tSystem.out.println(\"Sorted array is:\" + java.util.Arrays.toString(arr));\n}",
    "Go": "func pancakesort(arr []int) {\n\tn := len(arr)\n\tfor n > 1 {\n\t\t// Find index of the maximum element in the unsorted part\n\t\tmaxIndex := 0\n\t\tfor i := 0; i < n; i++ {\n\t\t\tif arr[i] > arr[maxIndex] {\n\t\t\t\tmaxIndex = i\n\t\t\t}\n\t\t}\n\t\t// Flip elements from the beginning to the index of the maximum element\n\t\treverse(arr[:maxIndex+1])\n\t\t// Flip elements from the beginning to the new end (excluding the maximum element)\n\t\treverse(arr[:n])\n\t\tn--  // Reduce the unsorted part\n\t}\n\n\t// Helper function for reversing a slice\n\tfunc reverse(slice []int) {\n\t\tfor i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {\n\t\t\tslice[i], slice[j] = slice[j], slice[i]\n\t\t}\n\t}\n\n\t// Test array\n\tarr := []int{3, 2, 4, 1}\n\tpancakesort(arr)\n\tfmt.Println(\"Sorted array is:\", arr)\n}",
    "C": "void pancakesort(int arr[], int n) {\n\twhile (n > 1) {\n\t\t// Find index of the maximum element in the unsorted part\n\t\tint maxIndex = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr[i] > arr[maxIndex]) {\n\t\t\t\tmaxIndex = i;\n\t\t\t}\n\t\t}\n\t\t// Flip elements from the beginning to the index of the maximum element\n\t\tflip(arr, 0, maxIndex);\n\t\t// Flip elements from the beginning to the new end (excluding the maximum element)\n\t\tflip(arr, 0, n - 1);\n\t\tn--;  // Reduce the unsorted part\n\t}\n\n\t// Helper function for reversing a subarray\n\tvoid flip(int arr[], int start, int end) {\n\t\twhile (start < end) {\n\t\t\tint temp = arr[start];\n\t\t\tarr[start] = arr[end];\n\t\t\tarr[end] = temp;\n\t\t\tstart++;\n\t\t\tend--;\n\t\t}\n\t}\n\n\t// Test array\n\tint arr[] = {3, 2, 4, 1};\n\tint n = sizeof(arr) / sizeof(arr[0]);\n\tpancakesort(arr, n);\n\tprintf(\"Sorted array is: \");\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", arr[i]);\n\t}\n}"
  }
}
