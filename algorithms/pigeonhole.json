{
  "Name": "Pigeonhole Sort",
  "Date": "Ancient",
  "Author": "Unknown",
  "Description": "Pigeonhole sort is a sorting algorithm that relies on a fixed-size array (pigeonhole) to represent the range of possible values in the input data. It works under the assumption that the data has a limited range of values.\n\nEach element in the input array is used as an index to place it in the corresponding pigeonhole. After all elements are placed, the pigeonhole array is iterated through, and the elements within each pigeonhole are output, effectively sorting them.\n\n While pigeonhole sort has a time complexity of O(n + 2ᴷ), where k is the range of possible values, it's limited by the requirement of a fixed-size pigeonhole array and a known value range. Its applicability is restricted to specific data scenarios.",
  "Complexity": {
    "Time": "O(n + 2ᴷ)",
    "Best": "O(n + 2ᴷ)",
    "Worst": "O(n + 2ᴷ)",
    "Space": "O(2ᴷ)",
    "Stable": "Yes"
  },
  "Algorithm": "async function sort(){let a=Math.min(...array);const r=Math.max(...array)-a+1,t=Array(r).fill(0);for(let r=0;r<array.length;r++)t[array[r]-a]++;let e=0;for(let l=0;l<r;l++)for(;t[l]-- >0;)swap(array.indexOf(l+a),e++),await sleep(),firstRun=!1}",
  "Code": {
    "Python": "def pigeonhole_sort(arr):\n\tmin_value = min(arr)\n\tmax_value = max(arr)\n\tsize = max_value - min_value + 1\n\tholes = [[] for i in range(size)]\n\tfor i in arr:\n\t\tholes[i - min_value].append(i)\n\tarr = []\n\tfor i in range(size):\n\t\tfor item in holes[i]:\n\t\t\tarr.append(item)\n\treturn arr\n\n# Test array\narr = [8, 3, 2, 7, 4, 6, 9]\nprint('Sorted array is:', pigeonhole_sort(arr))",
    "JavaScript": "function pigeonholeSort(arr) {\n\tlet min_value = Math.min(...arr);\n\tlet max_value = Math.max(...arr);\n\tlet size = max_value - min_value + 1;\n\tlet holes = Array(size).fill([]);\n\tfor (let i of arr) {\n\t\tholes[i - min_value].push(i);\n\t}\n\tlet arr = [];\n\tfor (let i = 0; i < size; i++) {\n\t\tfor (let item of holes[i]) {\n\t\t\tarr.push(item);\n\t\t}\n\t}\n\treturn arr;\n\t}\n\n// Test array\nlet arr = [8, 3, 2, 7, 4, 6, 9];\nconsole.log('Sorted array is:', pigeonholeSort(arr));",
    "Java": "public static int[] pigeonholeSort(int[] arr) {\n\tint min_value = Integer.MIN_VALUE;\n\tint max_value = Integer.MAX_VALUE;\n\tfor (int i : arr) {\n\t\tmin_value = Math.min(min_value, i);\n\t\tmax_value = Math.max(max_value, i);\n\t}\n\tint size = max_value - min_value + 1;\n\tint[][] holes = new int[size][];\n\tfor (int i = 0; i < size; i++) {\n\t\tholes[i] = new int[0];\n\t}\n\tfor (int i : arr) {\n\t\tholes[i - min_value] = Arrays.copyOf(holes[i - min_value], holes[i - min_value].length + 1);\n\t\tholes[i - min_value][holes[i - min_value].length - 1] = i;\n\t}\n\tint[] arr_sorted = new int[arr.length];\n\tint index = 0;\n\tfor (int i = 0; i < size; i++) {\n\t\tfor (int item : holes[i]) {\n\t\t\tarr_sorted[index++] = item;\n\t\t}\n\t}\n\treturn arr_sorted;\n\t}\n\n// Test array\nint[] arr = {8, 3, 2, 7, 4, 6, 9};\nSystem.out.println('Sorted array is: ' + Arrays.toString(pigeonholeSort(arr)));",
    "Go": "func pigeonholeSort(arr []int) []int {\n\tmin_value := arr[0]\n\tmax_value := arr[0]\n\tfor _, val := range arr {\n\t\tmin_value = min(min_value, val)\n\t\tmax_value = max(max_value, val)\n\t}\n\tsize := max_value - min_value + 1\n\tholes := make([][]int, size)\n\tfor i := range holes {\n\t\tholes[i] = []int{}\n\t}\n\tfor _, val := range arr {\n\t\tholes[val - min_value] = append(holes[val - min_value], val)\n\t}\n\tarr_sorted := make([]int, 0, len(arr))\n\tfor _, hole := range holes {\n\t\tfor _, item := range hole {\n\t\t\tarr_sorted = append(arr_sorted, item)\n\t\t}\n\t}\n\treturn arr_sorted\n\t}\n\n// Test array\narr := []int{8, 3, 2, 7, 4, 6, 9}\nfmt.Println('Sorted array is:', pigeonholeSort(arr))",
    "C": "void pigeonhole_sort(int arr[], int n) {\n\tint min_value = arr[0];\n\tint max_value = arr[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tmin_value = min(min_value, arr[i]);\n\t\tmax_value = max(max_value, arr[i]);\n\t}\n\tint size = max_value - min_value + 1;\n\tint *holes = (int *)malloc(size * sizeof(int));\n\tfor (int i = 0; i < size; i++) {\n\t\tholes[i] = 0;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tholes[arr[i] - min_value]++;\n\t}\n\tint index = 0;\n\tfor (int i = 0; i < size; i++) {\n\t\tfor (int j = 0; j < holes[i]; j++) {\n\t\t\tarr[index++] = i + min_value;\n\t\t}\n\t}\n\tfree(holes);\n}\n\n// Test array\nint arr[] = {8, 3, 2, 7, 4, 6, 9};\nint n = sizeof(arr) / sizeof(arr[0]);\npigeonhole_sort(arr, n);\nprintf('Sorted array is: ');\nfor (int i = 0; i < n; i++) {\n\tprintf('%d ', arr[i]);\n}"
  }
}
