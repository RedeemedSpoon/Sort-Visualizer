{
  "Name": "Quick Sort",
  "Date": "1959",
  "Author": "Tony Hoare",
  "Description": "Quicksort is a divide-and-conquer sorting algorithm known for its efficiency. It operates by selecting a pivot element from the data structure (typically an array) and partitioning the remaining elements into two sub-arrays. Elements smaller than the pivot are placed in a sub-array to its left, and elements larger than the pivot are placed in a sub-array to its right.\n\nThis partitioning is achieved by iterating through the array while maintaining two indices: one for the left sub-array and another for the right. The pivot itself can be chosen in various ways, but common strategies include selecting the first, last, or a median element. Once the partitioning is complete, quicksort recursively sorts the two sub-arrays independently. This process continues until all sub-arrays have a single element (considered sorted) or become empty.\n\nThe average-case time complexity of quicksort is O(n log n), making it significantly faster than bubble sort or insertion sort for large datasets. However, its worst-case complexity can deteriorate to O(n²), which occurs when the chosen pivot consistently leads to unbalanced partitions.",
  "Complexity": {
    "Time": "O(n log n)",
    "Best": "O(n log n)",
    "Worst": "O(n²)",
    "Space": "O(log n)",
    "Stable": "No"
  },
  "Algorithm": "async function sort(){await async function a(t,n,i){if(n>=i)return;let r=await async function(a,t,n){let i=a[n],r=t-1;for(let e=t;e<=n-1;e++)if(a[e]<i&&(r++,swap(r,e),await sleep(),firstRun))return;if(swap(r+1,n),await sleep(),!firstRun)return r+1}(t,n,i);await a(t,n,r-1),await a(t,r+1,i)}(array,0,array.length-1)}",
  "Code": {
    "Python": "def quicksort(arr, lo, hi):\n\tif lo < hi:\n\t\tp = partition(arr, lo, hi)  # Partition the array and get the pivot element index.\n\t\tquicksort(arr, lo, p-1)  # Recursively sort the left partition.\n\t\tquicksort(arr, p+1, hi)  # Recursively sort the right partition.\n\n\tdef partition(arr, lo, hi):\n\t\tpivot = arr[hi]  # Choose the last element as the pivot.\n\t\ti = lo - 1  # index of smaller element\n\t\tfor j in range(lo, hi):\n\t\t\tif arr[j] <= pivot:\n\t\t\t\ti += 1\n\t\t\t\tarr[i], arr[j] = arr[j], arr[i]  # swap\n\t\tarr[i + 1], arr[hi] = arr[hi], arr[i + 1]  # swap pivot into its final position\n\t\treturn i + 1\n\n# Test array\narr = [12, 11, 13, 5, 6, 7]\nquicksort(arr, 0, len(arr) - 1)\nprint('Sorted array is:', arr)",
    "JavaScript": "function quicksort(arr, lo, hi) {\n\tif (lo < hi) {\n\t\tlet p = partition(arr, lo, hi); // Partition the array and get the pivot element index.\n\t\tquicksort(arr, lo, p - 1); // Recursively sort the left partition.\n\t\tquicksort(arr, p + 1, hi); // Recursively sort the right partition.\n\t}\n\n\tfunction partition(arr, lo, hi) {\n\t\tlet pivot = arr[hi]; // Choose the last element as the pivot.\n\t\tlet i = lo - 1; // index of smaller element\n\t\tfor (let j = lo; j < hi; j++) {\n\t\t\tif (arr[j] <= pivot) {\n\t\t\t\ti++;\n\t\t\t\t[arr[i], arr[j]] = [arr[j], arr[i]]; // swap using destructuring\n\t\t\t}\n\t\t}\n\t\t[arr[i + 1], arr[hi]] = [arr[hi], arr[i + 1]]; // swap pivot into its final position\n\t\treturn i + 1;\n\t}\n}\n\n// Test array\nlet arr = [12, 11, 13, 5, 6, 7];\nquicksort(arr, 0, arr.length - 1);\nconsole.log('Sorted array is:', arr);",
    "Java": "public static void quicksort(int[] arr, int lo, int hi) {\n\tif (lo < hi) {\n\t\tint p = partition(arr, lo, hi); // Partition the array and get the pivot element index.\n\t\tquicksort(arr, lo, p - 1); // Recursively sort the left partition.\n\t\tquicksort(arr, p + 1, hi); // Recursively sort the right partition.\n\t}\n\n\tprivate static int partition(int[] arr, int lo, int hi) {\n\t\tint pivot = arr[hi]; // Choose the last element as the pivot.\n\t\tint i = lo - 1; // index of smaller element\n\t\tfor (int j = lo; j < hi; j++) {\n\t\t\tif (arr[j] <= pivot) {\n\t\t\t\ti++;\n\t\t\t\tswap(arr, i, j); // swap function call\n\t\t\t}\n\t\t}\n\t\tswap(arr, i + 1, hi); // swap pivot into its final position\n\t\treturn i + 1;\n\t}\n\n\t// Swap function for clarity (optional)\n\tprivate static void swap(int[] arr, int i, int j) {\n\t\tint temp = arr[i];\n\t\tarr[i] = arr[j];\n\t\tarr[j] = temp;\n\t}\n\n\t// Test array\n\tint[] arr = {12, 11, 13, 5, 6, 7};\n\tquicksort(arr, 0, arr.length - 1);\n\tSystem.out.println(\"Sorted array is:\" + java.util.Arrays.toString(arr));\n}",
    "Go": "func quicksort(arr []int, lo, hi int) {\n\tif lo < hi {\n\t\tp := partition(arr, lo, hi) // Partition the array and get the pivot element index.\n\t\tquicksort(arr, lo, p-1) // Recursively sort the left partition.\n\t\tquicksort(arr, p+1, hi) // Recursively sort the right partition.\n\t}\n\n\tfunc partition(arr []int, lo, hi int) int {\n\t\tpivot := arr[hi] // Choose the last element as the pivot.\n\t\ti := lo - 1 // index of smaller element\n\t\tfor j := lo; j < hi; j++ {\n\t\t\tif arr[j] <= pivot {\n\t\t\t\ti++\n\t\t\t\tarr[i], arr[j] = arr[j], arr[i] // swap using assignment\n\t\t\t}\n\t\t}\n\t\tarr[i+1], arr[hi] = arr[hi], arr[i+1] // swap pivot into its final position\n\t\treturn i + 1\n\t}\n\n\t// Test array\n\tarr := []int{12, 11, 13, 5, 6, 7}\n\tquicksort(arr, 0, len(arr)-1)\n\tfmt.Println(\"Sorted array is:\", arr)\n}",
    "C": "void quicksort(int arr[], int lo, int hi) {\n\tif (lo < hi) {\n\t\tint p = partition(arr, lo, hi); // Partition the array and get the pivot element index.\n\t\tquicksort(arr, lo, p - 1); // Recursively sort the left partition.\n\t\tquicksort(arr, p + 1, hi); // Recursively sort the right partition.\n\t}\n\n\tint partition(int arr[], int lo, int hi) {\n\t\tint pivot = arr[hi]; // Choose the last element as the pivot.\n\t\tint i = lo - 1; // index of smaller element\n\t\tfor (int j = lo; j < hi; j++) {\n\t\t\tif (arr[j] <= pivot) {\n\t\t\t\ti++;\n\t\t\t\tswap(&arr[i], &arr[j]); // swap using pointers\n\t\t\t}\n\t\t}\n\t\tswap(&arr[i + 1], &arr[hi]); // swap pivot into its final position\n\t\treturn i + 1;\n\t}\n\n\t// Swap function for clarity (optional)\n\tvoid swap(int *a, int *b) {\n\t\tint temp = *a;\n\t\t*a = *b;\n\t\t*b = temp;\n\t}\n\n\t// Test array\n\tint arr[] = {12, 11, 13, 5, 6, 7};\n\tconst int n = sizeof(arr) / sizeof(arr[0]);\n\tquicksort(arr, 0, n - 1);\n\tprintf(\"Sorted array is: \");\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", arr[i]);\n\t}\n}"
  }
}
