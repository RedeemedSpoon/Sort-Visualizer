{
  "Name": "Tim Sort",
  "Date": "2002",
  "Author": "Tim Peters",
  "Description": "Timsort is a hybrid sorting algorithm that combines the strengths of insertion sort and merge sort. It is often used in Java's Arrays.sort() method due to its efficiency for most real-world data sets.\n\nTimsort initially partitions the input array into runs (partially sorted sub-arrays). For small runs, insertion sort is applied for its speed. When merging larger runs, a variant of merge sort is employed, optimized for already partially sorted data. This hybrid approach makes Timsort generally faster than pure insertion sort or merge sort for most data.",
  "Complexity": {
    "Time": "O(n log n)",
    "Best": "O(n)",
    "Worst": "O(n log n)",
    "Space": "O(n)",
    "Stable": "Yes"
  },
  "Algorithm": "",
  "Code": {
    "Python": "def timsort(arr, n):\n\trun_size = 32  # Define a small run size\n\n\t# Identify natural runs (already sorted subarrays)\n\tfor i in range(n):\n\t\tif i == 0 or arr[i] > arr[i - 1]:  # Start of a new run\n\t\t\tmin_run = max(run_size, i + 1)  # Minimum run size (including current element)\n\t\t\twhile i + 1 < n and arr[i + 1] >= arr[i]:  # Extend run if elements are increasing\n\t\t\t\ti += 1\n\t\t\tmax_run = min(n - i, 2 * run_size)  # Limit run size (avoid overflow)\n\n\t\t\t# Minimise run size if two previous runs are large enough\n\t\t\tif i > 0 and n - i >= min_run * 2:\n\t\t\t\t# In-place merge with the previous larger run\n\t\t\t\tj = i - min_run\n\t\t\t\twhile j < i and arr[j] > arr[i]:\n\t\t\t\t\tarr[i + 1], arr[j] = arr[j], arr[i + 1]\n\t\t\t\t\ti += 1\n\t\t\t\t\tj += 1\n\n\t# Timsort logic (in-place merging)\n\tfor i in range(0, n, run_size):  # Loop through potential runs\n\t\tend_run1 = min(i + run_size, n)  # End of first potential run\n\n\t\t# Check if next element starts a new run (avoid unnecessary merge)\n\t\tif end_run1 < n and arr[end_run1] >= arr[end_run1 - 1]:\n\t\t\tcontinue\n\n\t\t# Merge current run with the next run (if it exists)\n\t\tend_run2 = min(end_run1 + run_size, n)\n\t\twhile end_run1 < end_run2:\n\t\t\tif arr[end_run1] <= arr[end_run2 - 1]:\n\t\t\t\tend_run1 += 1\n\t\t\telse:\n\t\t\t\ttemp = arr[end_run2 - 1]\n\t\t\t\tj = end_run2 - 2\n\t\t\t\twhile j >= end_run1 and arr[j] > temp:\n\t\t\t\t\tarr[j + 1] = arr[j]\n\t\t\t\t\tj -= 1\n\t\t\t\tarr[j + 1] = temp\n\t\t\t\tend_run1 += 1\n\t\t\t\tend_run2 += 1\n\n# Test array\narr = [12, 11, 13, 5, 6, 7]\ntimSort(arr, len(arr))\nprint('Sorted array is:', arr)",
    "JavaScript": "function timsort(arr, n) {\n\tconst run_size = 32;\t// Define a small run size\n\n\t// Identify natural runs (already sorted subarrays)\n\tfor (let i = 0; i < n; i++) {\n\t\tif (i === 0 || arr[i] > arr[i - 1]) {\t// Start of a new run\n\t\t\tlet min_run = Math.max(run_size, i + 1);\t// Minimum run size\n\t\t\twhile (i + 1 < n && arr[i + 1] >= arr[i]) {\t// Extend run if elements are increasing\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tconst max_run = Math.min(n - i, 2 * run_size);\t// Limit run size (avoid overflow)\n\n\t\t\t// Minimise run size if two previous runs are large enough\n\t\t\tif (i > 0 && n - i >= min_run * 2) {\n\t\t\t\t// In-place merge with the previous larger run\n\t\t\t\tlet j = i - min_run;\n\t\t\t\twhile (j < i && arr[j] > arr[i]) {\n\t\t\t\t\tconst temp = arr[i];\n\t\t\t\t\tarr[i] = arr[j];\n\t\t\t\t\tarr[j] = temp;\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Timsort logic (in-place merging)\n\tfor (let i = 0; i < n; i += run_size) {\n\t\tconst end_run1 = Math.min(i + run_size, n);\t// End of first potential run\n\n\t\t// Check if next element starts a new run (avoid unnecessary merge)\n\t\tif (end_run1 < n && arr[end_run1] >= arr[end_run1 - 1]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Merge current run with the next run (if it exists)\n\t\tconst end_run2 = Math.min(end_run1 + run_size, n);\n\t\twhile (end_run1 < end_run2) {\n\t\t\tif (arr[end_run1] <= arr[end_run2 - 1]) {\n\t\t\t\tend_run1++;\n\t\t\t} else {\n\t\t\t\tconst temp = arr[end_run2 - 1];\n\t\t\t\tlet j = end_run2 - 2;\n\t\t\t\twhile (j >= end_run1 && arr[j] > temp) {\n\t\t\t\t\tarr[j + 1] = arr[j];\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\tarr[j + 1] = temp;\n\t\t\t\tend_run1++;\n\t\t\t\tend_run2++;\n\t\t\t}\n\t\t}\n\t}\n}",
    "Java": "public class Timsort {\n\tprivate static final int RUN_SIZE = 32;  // Define a small run size\n\n\tpublic static void sort(int[] arr, int n) {\n\t\t// Identify natural runs (already sorted subarrays)\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i == 0 || arr[i] > arr[i - 1]) {  // Start of a new run\n\t\t\t\tint minRun = Math.max(RUN_SIZE, i + 1);  // Minimum run size\n\t\t\t\twhile (i + 1 < n && arr[i + 1] >= arr[i]) {  // Extend run if increasing\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tint maxRun = Math.min(n - i, 2 * RUN_SIZE);  // Limit run size (avoid overflow)\n\n\t\t\t\t// Minimise run size if two previous runs are large enough\n\t\t\t\tif (i > 0 && n - i >= minRun * 2) {\n\t\t\t\t\t// In-place merge with the previous larger run\n\t\t\t\t\t\tint j = i - minRun;\n\t\t\t\t\t\twhile (j < i && arr[j] > arr[i]) {\n\t\t\t\t\t\t\tswap(arr, i, j);\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Timsort logic (in-place merging)\n\t\tfor (int i = 0; i < n; i += RUN_SIZE) {\n\t\t\tint endRun1 = Math.min(i + RUN_SIZE, n);  // End of first potential run\n\n\t\t\t// Check if next element starts a new run (avoid unnecessary merge)\n\t\t\tif (endRun1 < n && arr[endRun1] >= arr[endRun1 - 1]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Merge current run with the next run (if it exists)\n\t\t\tint endRun2 = Math.min(endRun1 + RUN_SIZE, n);\n\t\t\twhile (endRun1 < endRun2) {\n\t\t\t\tif (arr[endRun1] <= arr[endRun2 - 1]) {\n\t\t\t\t\tendRun1++;\n\t\t\t\t} else {\n\t\t\t\t\tint temp = arr[endRun2 - 1];\n\t\t\t\t\tint j = endRun2 - 2;\n\t\t\t\t\twhile (j >= endRun1 && arr[j] > temp) {\n\t\t\t\t\t\tarr[j + 1] = arr[j];\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t\tarr[j + 1] = temp;\n\t\t\t\t\tendRun1++;\n\t\t\t\t\tendRun2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void swap(int[] arr, int i, int j) {\n\t\tint temp = arr[i];\n\t\tarr[i] = arr[j];\n\t\tarr[j] = temp;\n\t}\n}",
    "Go": "package timsort\n\nconst runSize = 32  // Define a small run size\n\nfunc sort(arr []int, n int) {\n\t// Identify natural runs (already sorted subarrays)\n\tfor i := 0; i < n; i++ {\n\t\tif i == 0 || arr[i] > arr[i-1] {  // Start of a new run\n\t\t\tminRun := max(runSize, i+1)  // Minimum run size (including current element)\n\t\t\tfor i+1 < n && arr[i+1] >= arr[i] {  // Extend run if elements are increasing\n\t\t\t\ti++\n\t\t\t}\n\t\t\tmaxRun := min(n-i, 2*runSize)  // Limit run size (avoid overflow)\n\n\t\t\t// Minimise run size if two previous runs are large enough\n\t\t\tif i > 0 && n-i >= minRun*2 {\n\t\t\t\t// In-place merge with the previous larger run\n\t\t\t\t\tj := i - minRun\n\t\t\t\t\tfor j < i && arr[j] > arr[i] {\n\t\t\t\t\t\tarr[i], arr[j] = arr[j], arr[i]\n\t\t\t\t\t\ti++\n\t\t\t\t\t\tj++\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Timsort logic (in-place merging)\n\tfor i := 0; i < n; i += runSize {\n\t\tendRun1 := min(i+runSize, n)  // End of first potential run\n\n\t\t// Check if next element starts a new run (avoid unnecessary merge)\n\t\tif endRun1 < n && arr[endRun1] >= arr[endRun1-1] {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Merge current run with the next run (if it exists)\n\t\tendRun2 := min(endRun1+runSize, n)\n\t\tfor endRun1 < endRun2 {\n\t\t\tif arr[endRun1] <= arr[endRun2-1] {\n\t\t\t\tendRun1++\n\t\t\t} else {\n\t\t\t\ttemp := arr[endRun2-1]\n\t\t\t\t\tj := endRun2 - 2\n\t\t\t\t\tfor j >= endRun1 && arr[j] > temp {\n\t\t\t\t\t\tarr[j+1] = arr[j]\n\t\t\t\t\t\tj--\n\t\t\t\t\t}\n\t\t\t\t\tarr[j+1] = temp\n\t\t\t\t\tendRun1++\n\t\t\t\t\tendRun2++\n\t\t\t}\n\t\t}\n\t}\n}",
    "C": "#include <stdio.h>\n\n#define RUN_SIZE 32  // Define a small run size\n\nvoid swap(int *a, int *b) {\n\t// Swap function for in-place merging\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n\nvoid timsort(int arr[], int n) {\n\t// Identify natural runs (already sorted subarrays)\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || arr[i] > arr[i - 1]) {  // Start of a new run\n\t\t\tint min_run = (i + 1 > RUN_SIZE) ? i + 1 : RUN_SIZE;  // Minimum run size\n\t\t\twhile (i + 1 < n && arr[i + 1] >= arr[i]) {  // Extend run if increasing\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tint max_run = (n - i > 2 * RUN_SIZE) ? 2 * RUN_SIZE : (n - i);  // Limit run size\n\t\t\t// Minimise run size if two previous runs are large enough\n\t\t\tif (i > 0 && n - i >= min_run * 2) {\n\t\t\t\t// In-place merge with the previous larger run\n\t\t\t\t\tint j = i - min_run;\n\t\t\t\t\twhile (j < i && arr[j] > arr[i]) {\n\t\t\t\t\t\tswap(&arr[i], &arr[j]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Timsort logic (in-place merging)\n\tfor (int i = 0; i < n; i += RUN_SIZE) {\n\t\tint end_run1 = (i + RUN_SIZE < n) ? (i + RUN_SIZE) : n;  // End of first potential run\n\n\t\t// Check if next element starts a new run (avoid unnecessary merge)\n\t\tif (end_run1 < n && arr[end_run1] >= arr[end_run1 - 1]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Merge current run with the next run (if it exists)\n\t\tint end_run2 = (end_run1 + RUN_SIZE < n) ? (end_run1 + RUN_SIZE) : n;\n\t\twhile (end_run1 < end_run2) {\n\t\t\tif (arr[end_run1] <= arr[end_run2 - 1]) {\n\t\t\t\tend_run1++;\n\t\t\t} else {\n\t\t\t\tint temp = arr[end_run2 - 1];\n\t\t\t\tint j = end_run2 - 2;\n\t\t\t\t\twhile (j >= end_run1 && arr[j] > temp) {\n\t\t\t\t\t\tarr[j + 1] = arr[j];\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t\tarr[j + 1] = temp;\n\t\t\t\t\tend_run1++;\n\t\t\t\t\tend_run2++;\n\t\t\t}\n\t\t}\n\t}\n}"
  }
}
