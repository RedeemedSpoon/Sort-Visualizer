{
  "Name": "Tim Sort",
  "Date": "2002",
  "Author": "Tim Peters",
  "Description": "Timsort is a hybrid sorting algorithm that combines the strengths of insertion sort and merge sort. It is often used in Java's Arrays.sort() method due to its efficiency for most real-world data sets.\n\nTimsort initially partitions the input array into runs (partially sorted sub-arrays). For small runs, insertion sort is applied for its speed. When merging larger runs, a variant of merge sort is employed, optimized for already partially sorted data. This hybrid approach makes Timsort generally faster than pure insertion sort or merge sort for most data.",
  "Complexity": {
    "Time": "O(n log n)",
    "Best": "O(n)",
    "Worst": "O(n log n)",
    "Space": "O(n)",
    "Stable": "Yes"
  },
  "Algorithm": "",
  "Code": {
    "Python": "def timsort(arr):\n\tn = len(arr)\n\tmin_run = 32\n\n\tfor i in range(0, n, min_run):\n\t\tend = min(i + min_run - 1, n - 1)\n\t\tinsertion_sort(arr, i, end)\n\n\tsize = min_run\n\twhile size < n:\n\t\tfor i in range(0, n, size * 2):\n\t\t\tmid = min(i + size - 1, n - 1)\n\t\t\tend = min(i + size * 2 - 1, n - 1)\n\t\t\tmerge(arr, i, mid, end)\n\t\tsize *= 2\n\n\tdef insertion_sort(arr, left, right):\n\t\tfor i in range(left + 1, right + 1):\n\t\t\tkey = arr[i]\n\t\t\tj = i - 1\n\t\t\twhile j >= left and arr[j] > key:\n\t\t\t\tarr[j + 1] = arr[j]\n\t\t\t\tj -= 1\n\t\t\tarr[j + 1] = key\n\n\tdef merge(arr, left, mid, right):\n\t\tlen1 = mid - left + 1\n\t\tlen2 = right - mid\n\n\t\tleft_half = [0] * (len1)\n\t\tright_half = [0] * (len2)\n\n\t\tfor i in range(0, len1):\n\t\t\tleft_half[i] = arr[left + i]\n\n\t\tfor i in range(0, len2):\n\t\t\tright_half[i] = arr[mid + 1 + i]\n\n\t\ti = 0\n\t\tj = 0\n\t\tk = left\n\t\twhile i < len1 and j < len2:\n\t\t\tif left_half[i] <= right_half[j]:\n\t\t\t\tarr[k] = left_half[i]\n\t\t\t\ti += 1\n\t\t\telse:\n\t\t\t\tarr[k] = right_half[j]\n\t\t\t\tj += 1\n\t\t\tk += 1\n\n\t\twhile i < len1:\n\t\t\tarr[k] = left_half[i]\n\t\t\ti += 1\n\t\t\tk += 1\n\n\t\twhile j < len2:\n\t\t\tarr[k] = right_half[j]\n\t\t\tj += 1\n\t\t\tk += 1",
    "JavaScript": "function timsort(arr) {\n\tconst n = arr.length;\n\tconst minRun = 32;\n\n\tfor (let i = 0; i < n; i += minRun) {\n\t\tconst end = Math.min(i + minRun - 1, n - 1);\n\t\tinsertionSort(arr, i, end);\n\t}\n\n\tlet size = minRun;\n\twhile (size < n) {\n\t\tfor (let i = 0; i < n; i += size * 2) {\n\t\t\tconst mid = Math.min(i + size - 1, n - 1);\n\t\t\tend = min(i + size * 2 - 1, n - 1);\n\t\t\tmerge(arr, i, mid, end);\n\t\t}\n\t\tsize *= 2;\n\t}\n\n\tfunction insertionSort(arr, left, right) {\n\t\tfor (let i = left + 1; i <= right; i++) {\n\t\t\tconst key = arr[i];\n\t\t\tlet j = i - 1;\n\t\t\twhile (j >= left && arr[j] > key) {\n\t\t\t\tarr[j + 1] = arr[j];\n\t\t\t\tj -= 1;\n\t\t\t}\n\t\t\tarr[j + 1] = key;\n\t\t}\n\t}\n}",
    "Java": "public class TimSort {\n\tpublic static void timsort(int arr[]) {\n\t\tint n = arr.length;\n\t\tint minRun = 32;\n\n\t\tfor (int i = 0; i < n; i += minRun) {\n\t\t\tint end = Math.min(i + minRun - 1, n - 1);\n\t\t\tinsertionSort(arr, i, end);\n\t\t}\n\n\t\tint size = minRun;\n\t\twhile (size < n) {\n\t\t\tfor (int i = 0; i < n; i += size * 2) {\n\t\t\t\tint mid = Math.min(i + size - 1, n - 1);\n\t\t\t\tint end = Math.min(i + size * 2 - 1, n - 1);\n\t\t\t\tmerge(arr, i, mid, end);\n\t\t\t}\n\t\t\tsize *= 2;\n\t\t}\n\t}\n\n\tpublic static void insertionSort(int arr[], int left, int right) {\n\t\tfor (int i = left + 1; i <= right; i++) {\n\t\t\tint key = arr[i];\n\t\t\tint j = i - 1;\n\t\t\twhile (j >= left && arr[j] > key) {\n\t\t\t\tarr[j + 1] = arr[j];\n\t\t\t\tj -= 1;\n\t\t\t}\n\t\t\tarr[j + 1] = key;\n\t\t}\n\t}\n\n\tpublic static void merge(int arr[], int left, int mid, int right) {\n\t\tint len1 = mid - left + 1;\n\t\tint len2 = right - mid;\n\n\t\tint leftHalf[] = new int[len1];\n\t\tint rightHalf[] = new int[len2];\n\n\t\tfor (int i = 0; i < len1; i++) {\n\t\t\tleftHalf[i] = arr[left + i];\n\t\t}\n\n\t\tfor (int i = 0; i < len2; i++) {\n\t\t\trightHalf[i] = arr[mid + 1 + i];\n\t\t}\n\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = left;\n\t\twhile (i < len1 && j < len2) {\n\t\t\tif (leftHalf[i] <= rightHalf[j]) {\n\t\t\t\tarr[k] = leftHalf[i];\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tarr[k] = rightHalf[j];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\twhile (i < len1) {\n\t\t\tarr[k] = leftHalf[i];\n\t\t\ti++;\n\t\t\tk++;\n\t\t}\n\n\t\twhile (j < len2) {\n\t\t\tarr[k] = rightHalf[j];\n\t\t\tj++;\n\t\t\tk++;\n\t\t}\n\t}\n}",
    "Go": "func timSort(data []interface{}, less func(i, j int) bool) {\n\tminRun := 32\n\n\tn := len(data)\n\tstack := make([]int, 0, n/minRun+10)\n\n\t// Initial partition into runs\n\tfor i := 0; i < n; i++ {\n\t\tif i == n-1 || !less(i, i+1) {\n\t\t\tend := i + 1\n\t\t\tif end-i < minRun {\n\t\t\t\tinsertionSort(data, i, end)\n\t\t\t} else {\n\t\t\t\tstack = append(stack, i, end)\n\t\t\t}\n\t\t\ti = end\n\t\t}\n\t}\n\n\t// Merge runs from the stack\n\tfor len(stack) > 0 {\n\t\tright := stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-2]\n\t\tleft := stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\t\tmerge(data, left, right, less)\n\t}\n}\n\nfunc insertionSort(data []interface{}, left, right int) {\n\tfor i := left + 1; i < right; i++ {\n\t\tcurrent := data[i]\n\t\tj := i\n\t\tfor j > left && less(current, j-1) {\n\t\t\tdata[j] = data[j-1]\n\t\t\tj--\n\t\t}\n\t\tdata[j] = current\n\t}\n}\n\nfunc merge(data []interface{}, left, right int, less func(i, j int) bool) {\n\t// Handle already sorted sub-arrays\n\tif less(right-1, left) {\n\t\treturn\n\t}\n\n\tmid := (left + right) / 2\n\t// Check if left and right sub-arrays are already sorted runs\n\tif !less(mid-1, left) && !less(right-1, mid) {\n\t\treturn\n\t}\n\n\t// Merge the two sub-arrays\n\ti, j, k := left, mid, left\n\ttemp := make([]interface{}, right-left)\n\tfor i < mid && j < right {\n\t\tif less(data[i], data[j]) {\n\t\t\ttemp[k] = data[i]\n\t\t\ti++\n\t\t} else {\n\t\t\ttemp[k] = data[j]\n\t\t\tj++\n\t\t}\n\t\tk++\n\t}\n\t// Copy remaining elements\n\tfor i < mid {\n\t\ttemp[k] = data[i]\n\t\ti++\n\t\tk++\n\t}\n\tfor j < right {\n\t\ttemp[k] = data[j]\n\t\tj++\n\t\tk++\n\t}\n\t// Copy back the sorted data\n\tcopy(data[left:right], temp)\n}",
    "C": "#include <stdlib.h>\n\n// Function to compare two elements\ntypedef int (*compare_fn_t)(const void *, const void *);\n\n// Function to swap two elements\nvoid swap(void *a, void *b, size_t size) {\n\tchar *temp = malloc(size);\n\tmemcpy(temp, a, size);\n\tmemcpy(a, b, size);\n\tmemcpy(b, temp, size);\n\tfree(temp);\n}\n\n// Function to calculate minimum run length based on array size\nsize_t calculate_min_run(size_t num) {\n\tsize_t r = 0; // initialize run length\n    while (num >= 64) {\n        num >>= 1;\n        r |= 1;\n    }\n    return (r + 1) << 1;\n}\n\n// Function to sort a sub-array using insertion sort\nvoid insertion_sort(void *base, size_t num, size_t size, compare_fn_t compare) {\n\tfor (size_t i = 1; i < num; i++) {\n\t\tvoid *key = (char *)base + i * size;\n\t\tsize_t j = i;\n\t\twhile (j > 0 && compare((char *)base + (j - 1) * size, key) > 0) {\n\t\t\tswap((char *)base + (j - 1) * size, key, size);\n\t\t\t--j;\n\t\t}\n\t}\n}\n\n// Function to merge two sub-arrays\nvoid merge(void *base, size_t left, size_t mid, size_t right, size_t size, compare_fn_t compare) {\n\tsize_t len1 = mid - left + 1;\n\tsize_t len2 = right - mid;\n\n\tvoid *left_half = malloc(len1 * size);\n\tvoid *right_half = malloc(len2 * size);\n\n\tmemcpy(left_half, (char *)base + left * size, len1 * size);\n\tmemcpy(right_half, (char *)base + (mid + 1) * size, len2 * size);\n\n\tsize_t i = 0, j = 0, k = left;\n\twhile (i < len1 && j < len2) {\n\t\tif (compare(left_half + (i * size), right_half + (j * size)) <= 0) {\n\t\t\tmemcpy((char *)base + (k * size), left_half + (i * size), size);\n\t\t\ti++;\n\t\t} else {\n\t\t\tmemcpy((char *)base + (k * size), right_half + (j * size), size);\n\t\t\tj++;\n\t\t}\n\t\tk++;\n\t}\n\n\twhile (i < len1) {\n\t\tmemcpy((char *)base + (k * size), left_half + (i * size), size);\n\t\t\ti++;\n\t\t\tk++;\n\t}\n\n\twhile (j < len2) {\n\t\tmemcpy((char *)base + (k * size), right_half + (j * size), size);\n\t\t\tj++;\n\t\t\tk++;\n\t}\n\n\tfree(left_half);\n\tfree(right_half);\n}\n\n// Timsort function\nvoid timsort(void *base, size_t num, size_t size, compare_fn_t compare) {\n\tsize_t min_run = calculate_min_run(num);\n\n\tfor (size_t i = 0; i < num; i += min_run) {\n\t\tsize_t end = i + min_run - 1;\n\t\tif (end >= num)\t\t\tend = num - 1;\n\t\tinsertion_sort(base, (char *)base + i * size, end - i + 1, compare);\n\t}\n\n\tsize_t min_run_power = 0; // initialize min_run_power\n\twhile (min_run < num) {\n\t\tfor (size_t i = 0; i < num; i += min_run * (1 << min_run_power)) {\n\t\t\tsize_t mid = i + min_run - 1;\n\t\t\tif (mid >= num) mid = num - 1;\n\t\t\tsize_t end = i + min_run * (1 << (min_run_power + 1)) - 1;\n\t\t\tif (end >= num) end = num - 1;\n\t\t\tmerge(base, left, mid, right, size, compare);\n\t\t}\n\t\tmin_run *= 2;\n\t\tmin_run_power++;\n\t}\n}"
  }
}
